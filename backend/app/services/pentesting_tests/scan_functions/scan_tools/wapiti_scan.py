import os
import re
import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
import urllib.parse
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
import sys
sys.stdout.reconfigure(encoding='utf-8')
notifier= Notifier()

class wapiti_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'wapiti.json')
        self.wapiti_vulnerabilities = self.vulnerabilities
        self.resultat_path = f"{results_path}/wapiti.json"
        self.report_path = report_path
        self.db= db
        self.user_id = user_id

    def start(self, username, password, token_auth, cookies):
        print("Starting the Wapiti scan...")
        notifier.send_to_websocket("Starting the Wapiti scan...", self.db, self.user_id, notif_type="info")
    
        # command = (
        #         f"docker run --rm --name wapiti -v {self.resultat_path}:/mnt/results "
        #         f"cyberwatch/wapiti -u {self.url} -m all "
        #         f"-f json -o /mnt/results/ "
        #         f"-l {self.setting['wapiti_level']} "
        #         f"--max-scan-time {self.setting['wapiti_scan_time']}"
        # )
        # commandlast = (
        #     f"wapiti -u {self.url} -m all -f json -o {self.resultat_path} "
        #     f"-l {self.setting['wapiti_level']} "
        #     f"--max-scan-time {self.setting['wapiti_scan_time']}"
        # ) 
        # command = (
        #     f"docker exec wapiti_container wapiti -u {self.url} -m all -f json -o {self.resultat_path}:/mnt/results/ "
        #     f"-l {self.setting['wapiti_level']} "
        #     f"--max-scan-time {self.setting['wapiti_scan_time']}"
        # )
        # if username and password:
        #     command+=f" --auth-user {username} --auth-password {password} --auth-method basic"
        # elif cookies:
        #     command+=f" --cookie-value {cookies}"
        try:
            command = ["bash", "commands.sh",  self.url, self.hostname, "wapiti", username, password, cookies]
            process = subprocess.Popen(
                command, shell=True, stdout=subprocess.PIPE, 
                stderr=subprocess.STDOUT, text=True, encoding="utf-8", 
                errors="replace" 
            )
            for line in iter(process.stdout.readline, ''):
                output = line.strip()
                if output:
                    print(output)
            process.wait()
            notifier.send_to_websocket("[Finished] Wapiti Scan completed.", self.db, self.user_id, notif_type="success")
            
        except subprocess.CalledProcessError as e:
            print("An error occurred during the scan:", e)
            notifier.send_to_websocket(f"An error occurred during the scan: {e}", self.db, self.user_id, notif_type="error") 

    def get_wapiti_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        wapiti_vulnerabilities_details = self.wapiti_vulnerabilities.copy()
        wapiti_scan_result_path = self.resultat_path
        if not os.path.exists(wapiti_scan_result_path):
            print(f"Wapiti scan result file not found: {wapiti_scan_result_path}")
            return None
        try:
            with open(wapiti_scan_result_path, encoding="utf-8") as wapiti_scan_result:
                data = json.load(wapiti_scan_result)
                level_priority = {
                    "High": 4,
                    "Medium": 3,
                    "Low": 2,
                    "Informational": 1
                }
                if "classifications" in data:
                    classification = data["classifications"]
                    vulnerabilities_and_additionals = {}
                    if "vulnerabilities" in data:
                        vulnerabilities_and_additionals.update(data["vulnerabilities"])
                    if "additionals" in data:
                        vulnerabilities_and_additionals.update(data["additionals"])
                    sorted_vulnerabilities_and_additionals = {}
                    for vul, details_list in vulnerabilities_and_additionals.items():
                        sorted_details = sorted(details_list, key=lambda x: level_priority.get(level_priority.get(str(x.get("level")), "Informational"), 0), reverse=True)
                        sorted_vulnerabilities_and_additionals[vul] = sorted_details
                    for vul, details_list in sorted_vulnerabilities_and_additionals.items():
                        number = len(details_list)
                        details_listC = classification.get(vul, {})
                        updated_details = []
                        comm= []
                        risk_label = "" 
                        priority_levels = {4: "High", 3: "Medium", 2: "Low", 1: "Informational"}
                        for details in details_list:
                            url_pattern = r'curl\s+"(http[s]?://[^\s]+)"'
                            match = re.search(url_pattern, details.get("curl_command"))
                            if match:
                                extracted_url = match.group(1)
                                decoded_url = urllib.parse.unquote(extracted_url)
                                parsed_url = urllib.parse.urlparse(decoded_url)
                                query_params = urllib.parse.parse_qs(parsed_url.query)
                                decoded_params = {key: [urllib.parse.unquote(value[0]) for value in values] for key, values in query_params.items()}
                                referer = None
                                data = None
                                if '-e' in details.get("curl_command", ""):
                                    referer_pattern = r'-e\s+"([^"]+)"' 
                                    referer_match = re.search(referer_pattern, details.get("curl_command"))
                                    if referer_match:
                                        referer = referer_match.group(1)
                                if '-d' in details.get("curl_command", ""):
                                    data_pattern = r'-d\s+"([^"]+)"'  
                                    data_match = re.search(data_pattern, details.get("curl_command"))
                                    if data_match:
                                        data = data_match.group(1)
                            updetails = {
                                "method": details.get("method"),
                                "url": decoded_url,
                                "parameters": urllib.parse.parse_qs(parsed_url.query),
                                "attack": details.get("info"),
                                # "info": details.get("info"),
                                # "query_params": decoded_params,
                                # "referer": referer,
                                # "data": data
                            }
                            updated_details.append(updetails)
                            risk_value = details.get("level")
                            risk_label = priority_levels.get(level_priority.get(str(risk_value), 1), "Informational")
                            ref_dict = details_listC.get("ref", {})
                            wstg_list = details_listC.get("wstg", [])

                            ref_array = [{"title": k, "url": v} for k, v in ref_dict.items()]
                            ref_array += [{"url": w} for w in wstg_list]
                            comm = {
                                "risk": risk_label, 
                                "description": details_listC.get("desc"),
                                "module": details.get("module"),
                                "solution": details_listC.get("sol"),
                                "reference": ref_array
                            }
                        wapiti_vulnerabilities_details[vul] = [number, updated_details, comm]
        except json.JSONDecodeError:
            print("Error: Could not decode JSON from Wapiti results.")
            return None
        wapiti_vulnerabilities_details = {k: v for k, v in wapiti_vulnerabilities_details.items() if v[0] > 0}    
        if wapiti_vulnerabilities_details:
            saved_results_path = self.save_report_to_json(wapiti_vulnerabilities_details, "wapiti", self.report_path)
        return wapiti_vulnerabilities_details

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        wapiti_results = self.get_wapiti_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if wapiti_results is None:
            print("No Wapiti results found.")

    def check_results_for_risk(self, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board,
                               jira_project_key, db: Session, user_id: int):
        wapiti_vulnerabilities_new = self.get_wapiti_results(token, channel_id, emails, db, user_id, save_to_db=True)
        if not wapiti_vulnerabilities_new:
            return False
        issue_description = ""
        contains_vuln_with_risk = any(details[0] > 0 for details in wapiti_vulnerabilities_new.values())
        for vuln_type, details in wapiti_vulnerabilities_new.items():
            if details[0] > 0:
                issue_description += f"{vuln_type}: {details[0]} vulnerabilities\n"
        if contains_vuln_with_risk:
            issue_summary = f"Vulnerabilities detected by Wapiti scan for {self.url}"
            issue_type = "Bug"
        else:
            issue_summary = f"No vulnerabilities detected by Wapiti scan for {self.url}"
            issue_type = "Task"
            issue_description = f"Tested URL: {self.url}\nNo vulnerabilities detected."
        try:
            issue_key = notifier.create_issue_in_active_sprint(
                jira_email, jira_token, jira_domain, jira_board,
                jira_project_key, issue_summary, issue_description, issue_type
            )
            report_path_res = self.get_file_path('Reports', 'wapiti.json')
            if os.path.exists(report_path_res):
                notifier.attach_report_to_issue(jira_email, jira_token, jira_domain, issue_key, report_path_res)
        except (HTTPException, FileNotFoundError) as e:
            print(f"Error in Jira integration: {e}")
            return False
        return contains_vuln_with_risk