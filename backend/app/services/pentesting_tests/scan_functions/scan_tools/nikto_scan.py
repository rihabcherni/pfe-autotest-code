import os
import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
from urllib.parse import urlparse, parse_qs, urljoin
import requests
from bs4 import BeautifulSoup
notifier =Notifier()
class nikto_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'nikto.json')
        self.nikto_vulnerabilities = self.vulnerabilities
        self.results_path = results_path
        self.report_path = report_path
        self.user_id = user_id
        self.db = db

    def is_internal_link(self, link):
        parsed_url = urlparse(link)
        return parsed_url.netloc == '' or parsed_url.netloc == urlparse(self.url).netloc

    def crawl_website(self, base_url, max_depth=2):
        visited = set()
        to_visit = [(base_url, 0)]
        base_domain = urlparse(base_url).netloc

        while to_visit:
            current_url, depth = to_visit.pop(0)
            normalized_url = urlparse(current_url)._replace(query="").geturl()
            if normalized_url in visited or depth > max_depth:
                continue
            visited.add(normalized_url)

            try:
                response = requests.get(current_url, timeout=5)
                soup = BeautifulSoup(response.text, 'html.parser')
                for tag in soup.find_all('a', href=True):
                    href = tag.get('href')
                    full_url = urljoin(current_url, href)
                    parsed = urlparse(full_url)
                    if parsed.netloc == base_domain:
                        cleaned_url = parsed._replace(fragment="", query="").geturl()
                        to_visit.append((cleaned_url, depth + 1))
            except Exception as e:
                print(f"‚ùå Erreur lors du crawl de {current_url} : {e}")
        return visited

    def extract_url_parameters(self, url):
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        return {key: values if len(values) > 1 else values[0] for key, values in params.items()}

    def extract_vuln_details(self, data):
        vulnerabilities = data.get("vulnerabilities", [])
        vulnerabilities_by_id = {}
        for vuln in vulnerabilities:
            details = {}
            vuln_id = vuln["id"]
            details["url"] = data.get("host", "") + vuln["url"]
            details["method"] = vuln.get("method", "GET")
            details["parameters"] = self.extract_url_parameters(details["url"])
            details["attack"] = vuln["msg"]
            if vuln_id not in vulnerabilities_by_id:
                vulnerabilities_by_id[vuln_id] = [0, [], {}]
            vulnerabilities_by_id[vuln_id][0] += 1
            vulnerabilities_by_id[vuln_id][1].append(details)
        return vulnerabilities_by_id

    def extract_transformed_data(self, data, details_file):
        with open(details_file, "r", encoding="utf-8") as file:
            details = json.load(file)

        transformed_data = {}
        for vuln_id, (count, entries, comm) in data.items():
            comm = comm if isinstance(comm, dict) else {}
            if vuln_id in details:
                title = details[vuln_id]["title"]
                comm.update({
                    "description": details[vuln_id]["description"],
                    "risk": details[vuln_id]["risk"],
                    "solution": details[vuln_id]["solution"]
                })
                transformed_data[title] = [count, entries, comm]
        return transformed_data

    def start(self, username, password, token_auth, cookies):
        print("üöÄ Starting Nikto scan...")
        try:
            all_links = self.crawl_website(self.url)
            print(f"{len(all_links)} internal URLs found.")
            os.makedirs(self.results_path, exist_ok=True)
            for i, link in enumerate(all_links):
                # filename = f"nikto_{i}.json"
                # docker_volume = f"{os.path.abspath(self.results_path)}:/mnt/results"  
                # command = (
                #     f"docker run --rm -v {docker_volume} alpine/nikto -e TARGET_URL={self.url} -C all -h {link} "
                #     f"-o /mnt/results/{filename} -Format json"  
                # )

                # command = (
                #     f"docker exec nikto_container -e TARGET_URL={self.url} -C all -h {link} "
                #     f"-o /mnt/results/{filename} -Format json"  
                # )
                # if username and password:
                #     command += f" -id {username}:{password}"
                #     print("üöÄ Starting Nikto scan authentification...")
                # if cookies:
                #     command+=f" -O STATIC-COOKIE={cookies}"
                # process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                # for line in iter(process.stdout.readline, ''):
                #     print(line.strip())
                # process.wait()
                # notifier.send_to_websocket(f"‚úÖ Finished scanning: {link}", self.db, self.user_id, notif_type="success")

                command = ["bash", "commands.sh", link, self.hostname, "nikto", username, password, cookies]

                process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True)
                for line in iter(process.stdout.readline, ''):
                    print(line.strip())
                process.wait()

                print(f"‚úÖ Finished scanning: {link}")
                notifier.send_to_websocket(f"‚úÖ Finished scanning: {link}", self.db, self.user_id, notif_type="success")
                
        except Exception as e:
            print(f"‚ùå An unexpected error occurred: {e}")
            notifier.send_to_websocket(f"‚ùå An unexpected error occurred: {e}", self.db, self.user_id, notif_type="error")
            

    def get_nikto_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            merged_results = {"vulnerabilities": [], "host": self.url}
            details_path = self.get_vulnerabilities_json_path('nikto_data.json')

            for filename in os.listdir(self.results_path):
                if filename.startswith("nikto_") and filename.endswith(".json"):
                    filepath = os.path.join(self.results_path, filename)
                    try:
                        with open(filepath, "r", encoding="utf-8") as file:
                            data = json.load(file)
                            if "vulnerabilities" in data:
                                merged_results["vulnerabilities"].extend(data["vulnerabilities"])
                    except Exception as e:
                        print(f"‚ùå Erreur lors du chargement de {filename} : {e}")
                        continue

            data = self.extract_vuln_details(merged_results)
            nikto_vulnerabilities_details = self.extract_transformed_data(data, details_path)
            saved_results_path = self.save_report_to_json(nikto_vulnerabilities_details, "nikto", self.report_path)
            print(f"‚úÖ Results saved in {saved_results_path}!")
            return nikto_vulnerabilities_details

        except Exception as e:
            print(f"‚ùå Error while reading Nikto results : {e}")
            notifier.send_to_websocket(f"‚ùå Erreur : {e}", self.db, self.user_id, notif_type="error")
            raise HTTPException(status_code=500, detail="Error while generating the report")

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        nikto_results = self.get_nikto_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if not nikto_results:
            print("‚ùå No Nikto results found.")

    # def start(self, username, password, token_auth, cookies):
    #     print("Starting the scan nikto...")
    #     notifier.send_to_websocket("Starting the scan nikto...",, self.db, self.user_id, notif_type="info")
    #     try:
    #         if not os.path.exists(self.resultat_path):
    #             os.makedirs(self.resultat_path)
    #         command = (
    #             f"docker run --rm "
    #             f"-v {self.resultat_path}:/mnt/results "
    #             f"-e TARGET_URL={self.url} "
    #             f"alpine/nikto -h {self.url} -mutate 1 -Tuning 1,2,3,4,5 -Display V -o /mnt/results/nikto.json -Format json"
    #         )
    #         if password and username:
    #             command+=f" -id {username}:{password}"
    #         print(command)
    #         process = subprocess.Popen(
    #             command,
    #             shell=True,
    #             stdout=subprocess.PIPE,
    #             stderr=subprocess.STDOUT,
    #             text=True
    #         )
    #         for line in iter(process.stdout.readline, ''):
    #             output = line.strip()
    #             print(output)
    #             notifier.send_to_websocket(output,, self.db, self.user_id, notif_type="info")
    #         process.wait()
    #         if process.returncode != 0:
    #             error_message = process.stderr.read().strip()
    #             print(f"‚ùå Erreur lors de l'ex√©cution de la commande : {error_message}")
    #             notifier.send_to_websocket(f"‚ùå Erreur : {error_message}", self.db, self.user_id, notif_type="error")
           
    #         print("‚úÖ Scan nikto termin√© avec succ√®s !")                      
    #         notifier.send_to_websocket("[Finished] nikto Scan completed.",, self.db, self.user_id, notif_type="info")
    #     except subprocess.CalledProcessError as e:
    #         print("An error occurred during the scan:", e)
    #         notifier.send_to_websocket(f"An error occurred during the scan: {e}",, self.db, self.user_id, notif_type="info")

    #     except Exception as e:
    #         print("An unexpected error occurred:", e)
    #         notifier.send_to_websocket(f"An unexpected error occurred: {e}", self.db, self.user_id, notif_type="error")
    
   

   
    # def extract_vuln_details(self, input_file):
    #     try:
    #         with open(input_file, "r", encoding="utf-8") as file:
    #             data = json.load(file)
    #     except json.JSONDecodeError as e:
    #         print(f"Erreur de d√©codage JSON : {e}")
    #         raise
    #     if isinstance(data, dict) and "vulnerabilities" in data:
    #         vulnerabilities = data["vulnerabilities"]
    #     else:
    #         print("Data structure is not as expected, missing 'vulnerabilities'.")
    #         raise ValueError("Unexpected data structure: Missing 'vulnerabilities' key.")
    #     vulnerabilities_by_id = {}
    #     for vuln in vulnerabilities:
    #         details={}
    #         vuln_id = vuln["id"]
    #         details["url"]= data["host"]+vuln["url"]
    #         details["method"]=vuln["method"]
    #         details["parameters"]=  self.extract_url_parameters(details["url"])
    #         details["attack"]=vuln["msg"]
    #         if vuln_id not in vulnerabilities_by_id:
    #             vulnerabilities_by_id[vuln_id] = [0, [], []]
    #         vulnerabilities_by_id[vuln_id][0] += 1
    #         vulnerabilities_by_id[vuln_id][1].append(details)
    #     return vulnerabilities_by_id
