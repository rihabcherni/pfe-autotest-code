import os
import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
import urllib.parse
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
import re
notifier =Notifier()

class XSStrike_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url,'XSStrike.json')
        self.XSStrike_vulnerabilities = self.vulnerabilities
        self.resultat_path = results_path
        self.report_path = report_path
        self.db =db
        self.user_id= user_id 

    def clean_log(self,log_path):
        with open(log_path, "r", encoding="utf-8") as file:
            log_content = file.read()
        clean_content = re.sub(r'\x1b\[[0-9;]*[A-Za-z]', '', log_content)
        with open(log_path, "w", encoding="utf-8") as file:
            file.write(clean_content)   
        print("✅ Log nettoyé avec succès!")

    def parse_log(self, log_path, res_path):
        with open(log_path, "r", encoding="utf-8") as file:
            log_content = file.read()

        parsed_pages = re.findall(r"Parsing\s+([^\s]+)", log_content)
        vuln_pages = re.findall(r"Vulnerable webpage:\s+(\S+)", log_content)
        vuln_entries = re.findall(r"Vector for\s+(\w+):\s+([^\n]+)", log_content)
        vuln_entries_clean = [(param, payload.split("\n")[0].strip()) for param, payload in vuln_entries]
        vuln_urls = re.findall(r"\[\+\] Potentially vulnerable objects found at\s+(\S+)", log_content)
        vuln_objects = re.findall(r"\d+\s+\t+([^\n]+)", log_content)  
        specific_vulnerable_objects = re.findall(r"document\.cookie\s*=\s*\"[^\"]*\";", log_content) 
        vuln_objects_dict = {}        
        for vuln_url in vuln_urls:
            vuln_objects_dict[vuln_url] = []

        for vuln_url in vuln_urls:
            vuln_objects_dict[vuln_url] = vuln_objects + specific_vulnerable_objects

        vulnerabilities = []
        for i, (param, payload) in enumerate(vuln_entries_clean):
            page = vuln_pages[i] if i < len(vuln_pages) else "Unknown"
            vulnerabilities.append({
                "page": page,
                "parameters": param,
                "payload": payload
            })

        report = {
            "parsed_pages": parsed_pages,  
            "vulnerable_pages": vuln_pages,
            "vulnerable_objects": vuln_objects_dict, 
            "vulnerabilities": vulnerabilities
        }
        with open(res_path, "w", encoding="utf-8") as json_file:
            json.dump(report, json_file, indent=4)

        print(f"✅ Rapport XSS généré avec succès: {res_path}")

    def start(self, username, password, token_auth, cookies):
        print("Starting the scan XSStrike...")
        notifier.send_to_websocket("Starting the scan XSStrike...", self.db, self.user_id, notif_type="info")
        
        try:
            XSStrike_path =  self.get_folder_path("tools")/ "XSStrike" / "xsstrike.py"
            if not os.path.exists(XSStrike_path):
                raise FileNotFoundError(f"XSStrike.py not found at {XSStrike_path}")
            command = (
                f"python {XSStrike_path} -u {self.url} --crawl -l 5 --threads 10 > {self.resultat_path}/XSStrike.txt 2>&1"
            )
            if cookies:
                command+=f" --cookies {cookies}"

            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )
            for line in iter(process.stdout.readline, ''):
                output = line.strip()
                print(output)
            process.wait()            
            notifier.send_to_websocket("[Finished] XSStrike Scan completed.", self.db, self.user_id, notif_type="success")
            
            self.clean_log(f"{self.resultat_path}/XSStrike.txt")
            self.parse_log(f"{self.resultat_path}/XSStrike.txt",f"{self.resultat_path}/XSStrike.json")

        except subprocess.CalledProcessError as e:
            print("An error occurred during the scan:", e)
            notifier.send_to_websocket(f"An error occurred during the scan: {e}", self.db, self.user_id, notif_type="error")
            
        except Exception as e:
            print("An unexpected error occurred:", e)
            notifier.send_to_websocket(f"An unexpected error occurred: {e}", self.db, self.user_id, notif_type="error")
            
   

    def get_XSStrike_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        XSStrike_scan_result_path = os.path.join(self.resultat_path,"XSStrike.json")
        if not os.path.exists(XSStrike_scan_result_path):
            print(f"Fichier non trouvé: {XSStrike_scan_result_path}")
            raise FileNotFoundError(f"XSStrike log file not found at {XSStrike_scan_result_path}")
        try:
            with open(XSStrike_scan_result_path, 'r', encoding="utf-8") as XSStrike_scan_result:
                try:
                    data = json.load(XSStrike_scan_result)
                except json.JSONDecodeError as e:
                    print(f"Erreur de décodage JSON : {e}")
                    raise HTTPException(status_code=500, detail="Erreur de décodage JSON")
            if "vulnerabilities" not in data:
                print("Clé 'vulnerabilities' non trouvée dans le JSON")
                raise HTTPException(status_code=500, detail="Clé 'vulnerabilities' manquante")
            details=[]
            for d in data["vulnerabilities"]: 
                details.append({
                    "url": d["page"],
                    "method": "GET",
                    "parameters":  {d["parameters"]: urllib.parse.unquote(d["payload"])},
                    "attack": urllib.parse.unquote(d["payload"])
                })
            XSStrike_vulnerabilities_details = {
                "Cross Site Scripting": [len(details), details]
            }
            saved_results_path = self.save_report_to_json(XSStrike_vulnerabilities_details,"XSStrike",self.report_path)
            return XSStrike_vulnerabilities_details
        except Exception as e:
            notifier.send_to_websocket(f"❌Error XSStrike result: {e}", self.db, self.user_id, notif_type="error")
            
            raise HTTPException(status_code=500, detail=f"❌Error XSStrike : {e}")

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        XSStrike_results = self.get_XSStrike_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if XSStrike_results is None:
            print("No XSStrike results found.")

    