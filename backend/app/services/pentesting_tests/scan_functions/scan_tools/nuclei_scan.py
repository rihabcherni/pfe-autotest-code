import os
import re
import subprocess
import json
from urllib.parse import parse_qs, urlparse
from sqlalchemy.orm import Session
import yaml
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
import sys
sys.stdout.reconfigure(encoding='utf-8')
notifier= Notifier()
class nuclei_scan(Scan):
    def __init__(self, setting, url,report_path,results_path, db, user_id):
        super().__init__(setting, url, 'nuclei.json')
        self.nuclei_vulnerabilities = self.vulnerabilities
        self.resultat_path = results_path
        self.report_path = report_path
        self.db = db
        self.user_id = user_id
    
    def generate_auth_yaml(self, output_path, domain, username, password, cookie_key, cookie_value, bearer_token, header_key, header_value ):
        data = {
            "static": [
                {
                    "type": "basicauth",
                    "domains": [domain],
                    "username": username,
                    "password": password
                },
                {
                    "type": "cookie",
                    "domains": [domain],
                    "cookies": [
                        {"key": cookie_key, "value": cookie_value}
                    ]
                },
                {
                    "type": "bearertoken",
                    "domains": [domain],
                    "token": bearer_token
                },
                {
                    "type": "header",
                    "domains": [domain],
                    "headers": [
                        {"key": header_key, "value": header_value}
                    ]
                }
            ]
        }

        with open(output_path, "w", encoding="utf-8") as file:
            yaml.dump(data, file, sort_keys=False)
        print(f"✅ YAML file created at: {output_path}")

    def start(self, username, password, token_auth, cookies):
        nuclei_version = subprocess.run(["nuclei", "-version"], capture_output=True, text=True)
        if nuclei_version.returncode != 0:
            print("❌ Nuclei n'est pas installé ou non accessible.")
            return
        print("Starting the scan nuclei...")
        if not os.path.exists(self.resultat_path):
            os.makedirs(self.resultat_path)
        notifier.send_to_websocket("Starting the scan  nuclei", self.db, self.user_id, notif_type="info")
        
        try:
            secret_file= f"{self.resultat_path}/nuclei-auth.yaml"
            if username or password or token_auth or cookies:
                self.generate_auth_yaml(
                    output_path=secret_file,
                    domain= urlparse(str(self.url)).netloc,
                    username=username,
                    password=password,
                    cookie_key=cookies,
                    cookie_value=cookies,
                    bearer_token=token_auth,
                    header_key="x-pdcp-key",
                    header_value="<api-key-here>"
                )
                command = ["bash", "commands.sh", self.url, self.hostname, "nuclei", username, password, cookies]

                # ++++ command = [
                #     "docker", "run", "--rm",
                #     "-v", f"{os.path.abspath(self.resultat_path)}:/data",  
                #     "projectdiscovery/nuclei:latest",
                #     "-u", self.url,
                #     "-json-export", "/data/nuclei.json"
                # ]
                # command= [
                #     "nuclei",
                #     "-l", f"{self.resultat_path}\\crawled_urls.txt",
                #     "-sf", "nuclei-auth.yaml",
                #     "-tags", "xss,sqli,cve,misconfig,token,auth,exposure",
                #     "-json-export", f"{self.resultat_path}\\auth-nuclei.json"
                # ]
                # command=  f"nuclei -u {self.url} -json-export {self.resultat_path}\\nuclei.json"
                # commandlast= f"docker exec nuclei_container -u {self.url} -json-export {self.resultat_path}\\nuclei.json"
                if os.path.exists(secret_file):
                    command += ["-sf", {secret_file}]
                print(command)
            process = subprocess.Popen(
               command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                text=True
            )
            for line in iter(process.stdout.readline, ''):
                output = line.strip()
                print(output)
            process.wait()
            notifier.send_to_websocket("[Finished] nuclei Scan completed.", self.db, self.user_id, notif_type="success")
            
        except subprocess.CalledProcessError as e:
            print("An error occurred during the scan:", e)
            notifier.send_to_websocket("An error occurred during the scan: {}".format(e), self.db, self.user_id, notif_type="error")
            
    def extract_url_parameters(self,url):
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        return {key: values if len(values) > 1 else values[0] for key, values in params.items()}

    def get_nuclei_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        nuclei_vulnerabilities_details = {}
        nuclei_scan_result_path = f"{self.resultat_path}/nuclei.json"

        try:
            with open(nuclei_scan_result_path, "r", encoding="utf-8") as nuclei_scan_result:
                data = json.load(nuclei_scan_result)

                if not isinstance(data, list):
                    print("Invalid JSON format: Expected a list of vulnerabilities.")
                    return None
                for vuln in data:
                    template_id = vuln.get("template-id", "")
                    details = {}
                    res={}
                    fields = [
                        "name", "severity", "description", "remediation",  "url", "matched-at"
                        ,"path", "type","host","scheme" ,"port", "request", "response" ,"ip" ,"extracted-results", "meta","interaction", "curl-command"
                    ]
                    for field in fields:
                        if field in vuln:
                            details[field] = vuln[field]
                    if "info" in vuln:
                        info_fields = ["severity", "description","reference",  "remediation"]
                        details.update({key: vuln["info"].get(key) for key in info_fields if key in vuln["info"]})
                    if template_id not in nuclei_vulnerabilities_details:
                        nuclei_vulnerabilities_details[template_id] = [0, [], {}]
                    res["url"]=details['matched-at']
                    match = re.match(r"^(GET|POST|PUT|DELETE|PATCH|OPTIONS|HEAD)", details['request'])
                    res["method"]= match.group(0) if match else ""
                    res["parameters"]= self.extract_url_parameters(res["url"])
                    res["type"]= details["type"]
                    res["extracted-results"]=  details.get('extracted-results', []) 
                    nuclei_vulnerabilities_details[template_id][0] += 1
                    nuclei_vulnerabilities_details[template_id][1].append(res)
                    nuclei_vulnerabilities_details[template_id][2] = {
                        "description": details.get('description', ''),
                        "solution":  details.get('remediation', ''),
                        "risk":  details.get('severity', ''), 
                        "reference":  details.get('reference', []), 
                    }
        except FileNotFoundError:
            print(f"Nuclei scan result file not found: {nuclei_scan_result_path}")
            return None
        if nuclei_vulnerabilities_details:
            saved_results_path = self.save_report_to_json(nuclei_vulnerabilities_details, "nuclei", self.report_path)
        return nuclei_vulnerabilities_details

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        nuclei_results = self.get_nuclei_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if nuclei_results is None:
            print("No nuclei results found.")