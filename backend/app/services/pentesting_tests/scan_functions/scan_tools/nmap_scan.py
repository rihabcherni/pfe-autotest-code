import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
import xml.etree.ElementTree as ET
from urllib.parse import urlparse, parse_qs
import json
import xml.etree.ElementTree as ET
import re
import urllib
import html
notifier= Notifier()
class nmap_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'nmap.json')
        self.nmap_vulnerabilities = self.vulnerabilities
        self.resultat_path = results_path
        self.report_path = report_path
        self.db= db
        self.user_id= user_id
    
    def extract_url_parameters(self, url):
        parsed_url = urlparse(url)
        params = parse_qs(parsed_url.query)
        return {key: values if len(values) > 1 else values[0] for key, values in params.items()}

    def extract_attacks(self, data):
        attacks = []
        
        for attack_type, (_, attack_list) in data.items():
            for attack in attack_list:
                if "details" not in attack:
                    continue
                details = attack["details"]
                urls = [line.strip() for line in details.split("\n") if line.strip().startswith("http")]
                
                for url in urls:
                    parsed_url = urlparse(url)
                    params = parse_qs(parsed_url.query)
                    
                    attack_info = {
                        "url": parsed_url.scheme + "://" + parsed_url.netloc + parsed_url.path,
                        "method": "GET" if params else "POST",
                        "parameters": {k: v[0] if len(v) == 1 else v for k, v in params.items()},
                        "attack_type": attack_type
                    }
                    
                    attacks.append(attack_info)
        return attacks
    
    def extract_vuln_details(self, xml_file, output_json):
        try:
            tree = ET.parse(xml_file)
            root = tree.getroot()
            vuln_data = {}
            for host in root.findall("host"):
                for port in host.findall("ports/port"):
                    for script in port.findall("script"):
                        script_id = script.get("id")
                        script_output = script.get("output", "")
                        if "Couldn't find any" in script_output or "No vulnerabilities found" in script_output:
                            continue  
                        if script_id not in vuln_data:
                            vuln_data[script_id] = [0, [], {}]
                        structured_attacks, details = self.parse_raw_output(script_id, script, script_output)
                        vuln_data[script_id][0] += len(structured_attacks)
                        vuln_data[script_id][1].extend(structured_attacks)
                        vuln_data[script_id][2]=details
            if not vuln_data:
                print("❌ No vulnerabilities found in XML.")
            with open(output_json, "w", encoding="utf-8") as json_file:
                json.dump(vuln_data, json_file, indent=4, ensure_ascii=False)
            print(f"✅ Extraction terminée. Résultats enregistrés dans {output_json}")

        except Exception as e:
            print(f"❌ Error while reading XML File: {e}")
    
    def parse_raw_output(self, script_id, script, script_output):
        attacks = []
        details = {
            "description": "",
            "risk": "",
            "solution": "",
            "reference": ""
        }
        if script_id == "http-sql-injection":
            sqli_urls = re.findall(r"http[^\s]+", script_output)
            for url in sqli_urls:
                url = re.sub(r":80\b", "", url)  
                parsed_url = urlparse(url)
                params = parse_qs(parsed_url.query)
                for param, values in params.items():
                    attacks.append({
                        "method": "GET" if params else "POST",
                        "url":  urllib.parse.unquote(url),
                        "path": f"{parsed_url.path}",
                        "parameters": params,
                        "attack": values[0] if values else "",
                    })
                    details["description"]= "The script spiders an HTTP server looking for URLs containing queries vulnerable to SQL injection attacks. It attempts to combine crafted SQL commands with vulnerable URLs to obtain errors, which are analyzed to determine if the URL is vulnerable. The script also extracts forms from websites and identifies fields that might be susceptible to SQL injection. It primarily uses basic SQL injection techniques and is not suited for more advanced attacks. This script may not work on virtually hosted sites if the target web server's true hostname is not accessible."
                    details["risk"]= "High"
                    details["reference"]= [ "http://code.google.com/p/fuzzdb/"]
                    details["solution"]= "The script attempts to identify and exploit SQL injection vulnerabilities in URLs and forms by injecting basic SQL commands. If vulnerabilities are detected, the response will include potential SQL injection points. Users should ensure their web applications implement proper input validation and prepared statements to prevent SQL injection attacks. Additionally, using web application firewalls (WAFs) and other intrusion detection systems can help mitigate such vulnerabilities."
        elif script_id == "http-csrf":
            csrf_matches = re.findall(r"Path:\s*(http[^\s]+)\s*Form id:\s*(.*?)\s*Form action:\s*(.*?)\s*(?=Path:|$)", script_output, re.DOTALL)
            for path, form_id, action in csrf_matches:
                attacks.append({
                    "method": "POST",
                    "url": re.sub(r":80\b", "", path),
                    "parameters": {},
                    "attack": action,
                    "form_id": form_id.strip() or "",
                })
            details["description"]= "This script detects Cross Site Request Forgeries (CSRF) vulnerabilities. It checks if each form contains an unpredictable token for each user. Without one, an attacker may forge malicious requests. The script identifies tokens by analyzing form attributes and calculating entropy levels."
            details["risk"]= "medium"
            details["reference"]=[
                "https://nmap.org/nsedoc/scripts/http-csrf.html"
            ]
            details["solution"]= "Ensure all forms that perform state-changing operations include a CSRF token. Implement SameSite cookies and CSRF protection mechanisms such as synchronizer tokens or challenge-response authentication."
        elif script_id == "http-enum":
            enum_matches = re.findall(r"/[^\s]+/:? [^\n]+", script_output)
            for match in enum_matches:
                path=match.split(":")[0]
                attacks.append({
                    "method": "GET",
                    "url": self.url+path,
                    "path": path,
                    "parameters": {},
                    "attack": match.split(":")[1].strip() if ":" in match else "Potentially interesting directory"
                })
                details["description"]= "Enumerates directories used by popular web applications and servers. It parses a fingerprint file similar to Nikto's database, performing advanced pattern matching to identify web applications and their versions. It avoids false positives by testing for servers that return incorrect 404 responses."
                details["risk"]="High"
                details["reference"]= [
                    "https://nmap.org/nsedoc/scripts/http-enum.html",
                    "http://seclists.org/nmap-dev/2009/q3/0685.html",
                    "http://seclists.org/nmap-dev/2013/q4/292"
                ]
                details["solution"]= "Use this script to identify web directories and potential vulnerabilities in a web server. To reduce false positives, ensure proper handling of 404 responses and avoid overly broad pattern matching."
        elif script_id == "http-cross-domain-policy":
            description = script.find(".//table[@key='description']/elem")
            description_text = description.text.strip() if description is not None and description.text else ""
            for check in script.findall(".//table[@key='check_results']/table"):
                name = check.find("elem[@key='name']")
                body = check.find("elem[@key='body']")
                path= name.text.strip() if name is not None and name.text else ""
                attacks.append({
                    "method": "GET",
                    "url": self.url+path,
                    "path": path,
                    "parameters": {},
                    "attack": html.unescape(body.text.strip()) if body is not None and body.text else ""
                })
            details["risk"]= "High"
            details["description"]= description_text
            details["reference"]= [elem.text.strip() for elem in script.findall(".//table[@key='refs']/elem") if elem.text]  
       
        elif script_id == "http-dombased-xss":
            attacks.append({})
            details["description"]= "This script detects potential DOM-based Cross Site Scripting (XSS) vulnerabilities by analyzing JavaScript execution and checking for attacker-controlled inputs. It looks for patterns where the DOM can be manipulated unsafely to execute arbitrary JavaScript."
            details["risk"]= "low"
            details["reference"]=  [
                "https://code.google.com/p/domxsswiki/wiki/LocationSources",
                "http://www.webappsec.org/projects/articles/071105.shtml"
            ]
            details["solution"]="Review JavaScript code to ensure untrusted data from the DOM is properly sanitized before being executed. Use Content Security Policy (CSP) and JavaScript libraries that encode or sanitize inputs."
        return attacks, details

    def start(self, username, password, token_auth, cookies):
        print("🚀 Starting the Nmap scan...")
        notifier.send_to_websocket("🚀 Starting the Nmap scan...", self.db, self.user_id, notif_type="info")
        
        try:
            command = (
                f"docker run --rm -v {self.resultat_path}:/mnt/results "
                f"parrotsec/nmap:latest -n -p- --script vuln {self.hostname} -oX /mnt/results/nmap.xml"
            )
            # command = (
            #     f"nmap -v -n -p- --script vuln {self.hostname} -oX {self.resultat_path}/nmap.xml"
            # )
            print(command)
            if password and username:
                command+= f" --script-args http-auth.username={username},http-auth.password={password}"
        
            command = ["bash", "commands.sh", self.url, self.hostname, "nmap", username, password, cookies,]
            process = subprocess.Popen(command, shell=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
            for line in iter(process.stdout.readline, ''):
                output = line.strip()
                print(output)
            process.wait()

            if process.returncode != 0:
                error_message = process.stderr.read().strip()
                print(f"❌ Erreur lors de l'exécution de la commande : {error_message}")
                notifier.send_to_websocket(f"❌ Erreur : {error_message}", self.db, self.user_id, notif_type="error")

            notifier.send_to_websocket("✅ [Finished] Nmap Scan completed.", self.db, self.user_id, type="success")  
            report_path = f"{self.report_path}/nmap.json"
            self.extract_vuln_details(f"{self.resultat_path}/nmap.xml", report_path)
            print(f"✅ Résultats enregistrés dans {report_path}!")                      

        except subprocess.CalledProcessError as e:
            print(f"❌ Une erreur est survenue pendant le scan : {e}")
            notifier.send_to_websocket(f"❌ Une erreur est survenue pendant le scan : {e}", self.db, self.user_id, notif_type="error")
            
        except Exception as e:
            print(f"❌ Une erreur inattendue est survenue : {e}")
            notifier.send_to_websocket(f"❌ Une erreur inattendue est survenue : {e}", self.db, self.user_id, notif_type="error")
            
    def get_nmap_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            report_path = f"{self.report_path}/nmap.json"

            with open(report_path, 'r', encoding="utf-8") as nmap_scan_result:
                nmap_vulnerabilities_details = json.load(nmap_scan_result)        
            return nmap_vulnerabilities_details

        except Exception as e:
            notifier.send_to_websocket(f"❌ Error while generating the report Nmap: {e}", self.db, self.user_id, notif_type="error")
            
            raise HTTPException(status_code=500, detail="Error while generating the report Nmap")

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        nmap_results = self.get_nmap_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if nmap_results is None:
            print("❌ Aucun résultat Nmap trouvé.")