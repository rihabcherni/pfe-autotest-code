import os
import subprocess
import time
import json
from http.client import HTTPException
from sqlalchemy.orm import Session
import urllib
from zapv2 import ZAPv2
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
from dotenv import load_dotenv
from urllib.parse import urlparse, parse_qs
import requests
load_dotenv()
notifier =Notifier()

class ZAP_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'zap.json')
        self.zap_vulnerabilities = self.vulnerabilities
        self.results_path = self.get_file_path(results_path, f'zap.json')
        self.risk_detected = False
        self.report_path = report_path
        self.db= db
        self.user_id=user_id 

    def get_zap_proxy(self):
        ports_to_try = [os.getenv('ZAP_PORT', '8080')]
        for port in ports_to_try:
            try:
                response = requests.get(f"http://127.0.0.1:{port}", timeout=2)
                if response.status_code < 500: 
                    print("[INFO] ZAP local detected on 127.0.0.1")
                    return {
                        'http': f"http://127.0.0.1:{port}",
                        'https': f"http://127.0.0.1:{port}"
                    }
            except requests.RequestException:
                continue
        print("[INFO] Falling back to ZAP container at zap")
        return {
            'http': f"http://zap:{os.getenv('ZAP_PORT', '8080')}",
            'https': f"http://zap:{os.getenv('ZAP_PORT', '8080')}"
        }

    def start(self):
        print("[INFO] zap server starting:")
        try:
            print("zap server started")
            notifier.send_to_websocket("zap server started", self.db, self.user_id, notif_type="info")
            
        except subprocess.CalledProcessError as e:
            print(f"[ERROR] Failed to start ZAP server: {e}")
            notifier.send_to_websocket(f"Failed to start ZAP {e}", self.db, self.user_id, notif_type="error")
            
            raise

    def check_for_zap(self, username, password, token_auth, cookies,context_name):
        print("The run of the zap scan begins.")
        zap_while_controler = "run_zap_scan"

        while zap_while_controler == "run_zap_scan":
            try:
                print("The loop of the scan begins.")
                zap = ZAPv2(apikey=os.getenv('ZAP_API_KEY'), proxies=self.get_zap_proxy())
                print("zap disable options begin.")
                zap.pscan.disable_all_scanners()
                zap.ascan.disable_scanners(ids=[6, 10045, 20015, 20019, 90024, 90034, 30001, 30002, 40008, 40028, 
                                                40029, 40032, 40034, 40035, 90026])
                zap.core.access_url(url=self.url)
                time.sleep(2)
                print("zap disable options finished.")
                def zap_spider_scan():
                    if username and password:
                        print("[INFO] Configuring authenticated scan...")
                        context_id, userId = self.configure_zap_authentication(zap, self.url, username, password,context_name)
                        scanID = zap.spider.scan_as_user(context_id, userId, self.url)
                        print("scanID"+scanID)
                    else:
                        print("[INFO] Running unauthenticated scan...")
                        scanID = zap.spider.scan(self.url, recurse=False, subtreeonly=True)
                        print("scanID"+scanID)
                    while int(zap.spider.status(scanID)) < 100:
                        print(f"Spider progress %: {zap.spider.status(scanID)}")
                        notifier.send_to_websocket(f"Spider progress %: {zap.spider.status(scanID)}", self.db, self.user_id, notif_type="progression")
                        
                        time.sleep(5)

                def zap_ajax_spider_scan(self, zap, username, context_name):
                    print("[INFO] Running AJAX Spider as user...")
                    try:
                        if username and context_name : 
                            scanID = zap.ajaxSpider.scanAsUser(contextName=context_name, userName=username, url=self.url)
                        else:    
                            scanID = zap.ajaxSpider.scan(self.url)
                        print(f"[INFO] AJAX Spider scan started with Scan ID: {scanID}")
                        timeout = time.time() + 60 * 2 
                        while zap.ajaxSpider.status(scanID) == 'running':
                            if time.time() > timeout:
                                print("[INFO] Timeout reached, stopping AJAX Spider scan.")
                                break
                            status = zap.ajaxSpider.status(scanID)
                            print(f"[INFO] AJAX Spider Scan status: {status}%")
                            time.sleep(2)
                        ajax_results = zap.ajaxSpider.results(start=0, count=10)
                        print("[INFO] AJAX Spider scan completed. Results: ", ajax_results)                    
                    except Exception as e:
                        print(f"[ERROR] Error during AJAX Spider scan: {e}")
                        raise

                print("The scan begins, check for settings.")
                if self.setting['zap_d'] > 0 and self.setting['zap_dc'] == 0:
                    print("Spider option 1")
                    zap.spider.set_option_max_depth(self.setting['zap_d'])
                    zap_spider_scan()
                elif self.setting['zap_dc'] > 0 and self.setting['zap_d'] == 0:
                    print("Spider option 2")
                    zap.spider.set_option_max_children(self.setting['zap_dc'])
                    zap_spider_scan()
                elif self.setting['zap_dc'] > 0 and self.setting['zap_d'] > 0:
                    print("Spider option 3")
                    zap.spider.set_option_max_depth(self.setting['zap_d'])
                    zap.spider.set_option_max_children(self.setting['zap_dc'])
                    zap_spider_scan()
                elif self.setting['zap_d'] == 0 and self.setting['zap_dc'] == 0:
                    print("Spider option 4")
                    print("The active scan begins.")
                    zap_spider_scan()

                time.sleep(1)

                if self.ajax_option:
                    if username and password:
                        print("Start auth zap ajax spider scan.")
                        zap_ajax_spider_scan(username,context_name)
                    else:
                        print("Start zap ajax spider scan.")
                        zap_ajax_spider_scan()

                scanID = zap.ascan.scan(self.url)
                time.sleep(2)
                while int(zap.ascan.status(scanID)) < 100:
                    print(f"Scan progress %: {zap.ascan.status(scanID)}")
                    notifier.send_to_websocket(f"Scan progress %: {zap.ascan.status(scanID)}", self.db, self.user_id, notif_type="progression")
                    
                    for alert in zap.alert.alerts(baseurl=self.url):
                        alert_message = f"URL: {alert.get('url')}, Risk '{alert.get('risk')}' , Plugin ID: {alert.get('pluginId')} detected by Zap in: {alert.get('alert')}"
                        if alert.get('risk') == 'High' and not self.risk_detected:
                            notifier.send_to_websocket(alert_message, self.db, self.user_id, notif_type="alert")
                            
                            self.risk_detected = True
                            break
                    time.sleep(1)

                print('[finished] Zap scan completed')
                notifier.send_to_websocket('[finished] Zap scan completed', self.db, self.user_id, notif_type="success")
                
                with open(self.results_path, 'w') as convert_file:
                    convert_file.write(json.dumps(zap.alert.alerts(baseurl=self.url)))
                
                zap_while_controler = "stop_zap_scan"
            except Exception as inst:
                print(f"[ERROR] Error during ZAP scan: {inst}")
                time.sleep(5)
                zap_while_controler = "run_zap_scan"

    def owaspzap_get_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        zap_vulnerabilities_new = self.zap_vulnerabilities.copy()
        
        with open(self.results_path, 'r') as read_file:
            zap_result = json.load(read_file)

        for i in zap_result:
            alert = i['alert'].encode('utf-8').decode('unicode_escape')
            
            if alert in zap_vulnerabilities_new:
                if not isinstance(zap_vulnerabilities_new[alert][1], list):
                    zap_vulnerabilities_new[alert][1] = []
                    zap_vulnerabilities_new[alert][2] = {
                        "description": i['description'],
                        "solution": i['solution'],
                        "reference": [i['reference']],
                        "confidence": i['confidence'],
                        "risk": i['risk']
                    }
                unique_identifier = (i['method'], i['url'], i['param'], i['attack'])
                
                if unique_identifier not in zap_vulnerabilities_new[alert][1]:
                    zap_vulnerabilities_new[alert][0] += 1 
                    zap_vulnerabilities_new[alert][1].append({
                        "method": i['method'],
                        "url": urllib.parse.unquote(i['url']),
                        "path": urlparse(i['url']).path,
                        "parameters": parse_qs(urlparse(i['url']).query),
                        "param": i['param'],
                        "attack": i['attack']
                    })

        zap_vulnerabilities_new = {alert: value for alert, value in zap_vulnerabilities_new.items() if value[0] > 0}
        
        self.save_report_to_json(zap_vulnerabilities_new, "zap", self.report_path)
        return zap_vulnerabilities_new

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        zap_results = self.owaspzap_get_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if zap_results is None:
            print("No zap results found.")

    def check_results_for_risk(self, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board,
                               jira_project_key, db: Session, user_id: int):
        zap_vulnerabilities_new = self.owaspzap_get_results(token, channel_id, emails, db, user_id, save_to_db=True)
        if not zap_vulnerabilities_new:
            return False
        issue_description = ""
        contains_vuln_with_risk = any(details[0] > 0 for details in zap_vulnerabilities_new.values())
        for vuln_type, details in zap_vulnerabilities_new.items():
            if details[0] > 0:
                issue_description += f"{vuln_type} : {details[0]} vulnerabilities\n"
        if contains_vuln_with_risk:
            issue_summary = f"Vulnerabilities detected by ZAP scan for {self.url}"
            issue_type = "Bug"
        else:
            issue_summary = f"No vulnerabilities detected by ZAP scan for {self.url}"
            issue_type = "Task"
            issue_description = f"Tested URL: {self.url}\nNo vulnerabilities detected."
        
        try:
            issue_key = notifier.create_issue_in_active_sprint(
                jira_email, jira_token, jira_domain, jira_board,
                jira_project_key, issue_summary, issue_description, issue_type
            )
            report_path_res = self.get_file_path('Reports', 'zap.json')
            if os.path.exists(report_path_res):
                notifier.attach_report_to_issue(jira_email, jira_token, jira_domain, issue_key, report_path_res)
        except (HTTPException, FileNotFoundError):
            return False
        return contains_vuln_with_risk

    def set_logged_in_indicator( self,zap,context_id):
        logged_in_regex = "\\Q<a href=\"logout.php\">Logout</a>\\E"
        logged_out_regex = "(?:Location: [./]*login\\.php)|(?:\\Q<form action=\"login.php\" method=\"post\">\\E)"
        zap.authentication.set_logged_in_indicator(context_id, logged_in_regex)
        zap.authentication.set_logged_out_indicator(context_id, logged_out_regex)
        print("[INFO] Login indicators configured.")

    def configure_zap_authentication(self, zap, target_url, username, password,context_name):
        context_id = zap.context.new_context(context_name)
        print(f"[INFO] Context '{context_name}' created with ID: {context_id}")
        zap.context.include_in_context(context_name, f"{target_url}.*")
        print(f"[INFO] {target_url} added to context {context_name}")
         
        auth_method = "formBasedAuthentication"
        login_url = f"loginUrl={target_url}/login.php"
        login_data = "loginRequestData=username%3D%7B%25username%25%7D%26password%3D%7B%25password%25%7D"
        auth_params = f"{login_url}&{login_data}"

        zap.authentication.set_authentication_method(context_id, auth_method, auth_params)
        print(f"[INFO] Authentication method configured for {context_name}")
        self.set_logged_in_indicator(zap,context_id)

        userId = zap.users.new_user(context_id, "User")
        print(f"[INFO] User created with ID: {userId}")

        credentials = f"username={username}&password={password}"
        zap.users.set_authentication_credentials(context_id, userId, credentials)
        zap.users.set_user_enabled(context_id, userId, True)
        print(f"[INFO] Credentials configured for user {userId}")
        return context_id, userId
    

    # def get_zap_container_ip(self):
    #     try:
    #         result = subprocess.run(
    #             ["docker", "inspect", "-f", "{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}", "zap_container"],
    #             stdout=subprocess.PIPE,
    #             stderr=subprocess.PIPE,
    #             text=True,
    #             check=True
    #         )
    #         ip_address = result.stdout.strip()
    #         print(f"[INFO] Detected ZAP container IP: {ip_address}")
    #         return ip_address
    #     except subprocess.CalledProcessError as e:
    #         print(f"[ERROR] Failed to get ZAP container IP: {e.stderr}")
    #         raise RuntimeError("Could not retrieve ZAP container IP")




# zap_container_ip = self.get_zap_container_ip() 
                # zap = ZAPv2(apikey=os.getenv('ZAP_API_KEY'), 
                #     proxies={ 
                #         'http': f'http://{zap_container_ip}:{os.getenv("ZAP_PORT")}', 
                #         'https': f'http://{zap_container_ip}:{os.getenv("ZAP_PORT")}' 
                # })

                # zap = ZAPv2(apikey=os.getenv('ZAP_API_KEY'), 
                #     proxies={ 
                #         'http': f'http://zap:{os.getenv("ZAP_PORT")}', 
                #         'https': f'http://zap:{os.getenv("ZAP_PORT")}' 
                # })