import os
import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
notifier =Notifier()

class Whatweb_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'Whatweb.json')
        self.Whatweb_vulnerabilities = self.vulnerabilities
        self.resultat_path = os.path.join(results_path, 'whatweb.json') 
        self.report_path = report_path
        self.db = db
        self.user_id = user_id

    def clean_log(self, input_file: str):
        # Check if file exists and has content
        if not os.path.exists(input_file):
            raise ValueError(f"Le fichier Whatweb {input_file} est introuvable.")
            
        if os.path.getsize(input_file) == 0:
            raise ValueError(f"Le fichier Whatweb {input_file} est vide.")

        try:
            with open(input_file, "r", encoding='utf-8') as f:
                raw_data = json.load(f)
        except json.JSONDecodeError as e:
            raise ValueError(f"Le fichier Whatweb {input_file} contient du JSON invalide: {e}")
            
        report = []
        for entry in raw_data:
            plugins = entry.get("plugins", {})

            def get_plugin_value(plugin, key="string", default=None, first=True):
                values = plugins.get(plugin, {}).get(key, default)
                if first and isinstance(values, list):
                    return values[0] if values else None
                return values

            result = {
                "Target": entry.get("target"),
                "HTTP Status": entry.get("http_status"),
                "IP Address": get_plugin_value("IP"),
                "Country": get_plugin_value("Country"),
                "Server": get_plugin_value("HTTPServer"),
                "PHP Version": get_plugin_value("PHP", "version"),
                "X-Powered-By": get_plugin_value("X-Powered-By"),
                "Script Type": get_plugin_value("Script"),
                "HTML Title": get_plugin_value("Title"),
                "Cookies": get_plugin_value("Cookies", first=False),
                "Email Found": get_plugin_value("Email"),
                "Strict-Transport-Security": get_plugin_value("Strict-Transport-Security"),
                "X-Frame-Options": get_plugin_value("X-Frame-Options"),
                "X-XSS-Protection": get_plugin_value("X-XSS-Protection"),
                "Uncommon Headers": get_plugin_value("UncommonHeaders", first=False),
                "ActiveX Modules": get_plugin_value("ActiveX", "module", first=False),
                "Object References": get_plugin_value("Object", "string", first=False),
                "Analytics ID": get_plugin_value("Google-Analytics", "account"),
                "Server via Proxy": get_plugin_value("Via-Proxy")
            }

            cleaned_result = {k: v for k, v in result.items() if v is not None and v != []}
            report.append(cleaned_result)
        return report
 
    def start(self, username, password, token_auth, cookies):
        print("Starting the scan Whatweb...")
        notifier.send_to_websocket("Starting the scan Whatweb...", self.db, self.user_id, notif_type="info")
        
        try:
            os.makedirs(os.path.dirname(self.resultat_path), exist_ok=True)
            scan_result = []

            command = ['docker', 'run', '--rm', 'secsi/whatweb', '-a', '3', '--log-json=/dev/stdout', self.url]
            if username and password:
                command.extend(['--user', f'{username}:{password}'])
            if cookies:
                command.extend(['--cookie', cookies])

            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False
            )

            if process.returncode != 0:
                error_msg = f"Whatweb scan failed with code {process.returncode}: {process.stderr}"
                print(error_msg)
                notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
                
                with open(self.resultat_path, 'w') as f:
                    json.dump([], f)
                return

            output_lines = process.stdout.strip().split('\n')
            for line in output_lines:
                line = line.strip()
                if not line:
                    continue
                try:
                    scan_result.append(json.loads(line))
                except json.JSONDecodeError:
                    # Tu peux logger Ã§a si besoin, ou juste ignorer silencieusement
                    pass

            with open(self.resultat_path, 'w', encoding='utf-8') as outfile:
                json.dump(scan_result, outfile)

            print(f"Whatweb scan completed successfully. Results saved to {self.resultat_path}")
            notifier.send_to_websocket("[Finished] Whatweb Scan completed.", self.db, self.user_id, notif_type="success")
            
        except Exception as e:
            error_msg = f"An unexpected error occurred in Whatweb scan: {e}"
            print(error_msg)
            notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
            
            with open(self.resultat_path, 'w') as f:
                json.dump([], f)

    def get_Whatweb_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            # Check if file exists and has content before processing
            if not os.path.exists(self.resultat_path):
                print(f"Warning: Results file not found at {self.resultat_path}")
                notifier.send_to_websocket(f"Results file not found", self.db, self.user_id, notif_type="warning")
                
                return []
                
            if os.path.getsize(self.resultat_path) == 0:
                print(f"Warning: Results file is empty at {self.resultat_path}")
                notifier.send_to_websocket(f"Results file is empty", self.db, self.user_id, notif_type="warning")
                
                return []
            
            results = self.clean_log(self.resultat_path)
            saved_results_path = self.save_report_to_json(results, "Whatweb", self.report_path)
            return results

        except Exception as e:
            print(f"Error reading Whatweb result: {e}")
            notifier.send_to_websocket(f"Error reading Whatweb result: {e}", self.db, self.user_id, notif_type="error")
            
            return []  

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        Whatweb_results = self.get_Whatweb_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if not Whatweb_results:
            print("No Whatweb results found.")
            
            notifier.send_to_websocket("No Whatweb results found", self.db, self.user_id, notif_type="warning")