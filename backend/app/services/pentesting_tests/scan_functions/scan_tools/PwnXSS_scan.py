
import os
import re
import subprocess
import json
from urllib.parse import parse_qs, urlparse
from fastapi import HTTPException
from sqlalchemy.orm import Session
import urllib
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
notifier= Notifier()
class PwnXSS_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'PwnXSS.json')
        self.PwnXSS_vulnerabilities = self.vulnerabilities
        # self.tool_path = self.get_folder_path("tools") / "PwnXSS" / "pwnxss.py"
        self.results_path = results_path
        self.report_path = report_path
        self.db = db
        self.user_id = user_id  
    def clean_log(self,log_path):
        with open(log_path, "r", encoding="utf-8") as file:
            log_content = file.read()

        clean_content = re.sub(r'\x1b\[[0-9;]*[A-Za-z]', '', log_content)
        
        with open(log_path, "w", encoding="utf-8") as file:
            file.write(clean_content)   
        print("✅ Log nettoyé avec succès!")

    def extract_xss_data(self, file_path):
        with open(file_path, 'r', encoding='utf-8') as file:
            console_output = file.read()

        xss_pattern = re.compile(r"\[(\d{2}:\d{2}:\d{2})\] \[CRITICAL\] Detected XSS \((GET|POST)\) at (http[s]?://[^\s]+).*?(\[.*?\])?")
        matches = re.findall(xss_pattern, console_output)
        vulnerabilities = []
        seen_vulnerabilities = set()

        for match in matches:
            method = match[1]
            url = match[2]
            parsed_url = urlparse(url)
            params = parse_qs(parsed_url.query)
            params_hashable = frozenset((key, tuple(value)) for key, value in sorted(params.items()))

            vulnerability_tuple = (url, method, str(parsed_url.scheme), str(parsed_url.path), str(parsed_url.netloc), params_hashable)
            if vulnerability_tuple in seen_vulnerabilities:
                continue
            seen_vulnerabilities.add(vulnerability_tuple)

            vulnerability = {
                "url": urllib.parse.unquote(url),
                "method": method,
                "path": parsed_url.path,
                "parameters": params
            }
            vulnerabilities.append(vulnerability)

        return vulnerabilities
    
    def start(self, username, password, token_auth, cookies):
        print("Starting the scan PwnXSS...")
        notifier.send_to_websocket("Starting the scan PwnXSS...", self.db, self.user_id, notif_type="info")
        command = ["bash", "commands.sh", self.url, self.hostname, "pwnxss", username, password, cookies]
        # command = f"set PYTHONIOENCODING=utf-8 && python {self.tool_path} -u {self.url} --depth {self.setting['depth_crawl']}"
        # if cookies:
        #     command+=f" --cookie {cookies}"
        output_file = os.path.join(self.results_path, "PwnXSS.txt")

        try:
            process = subprocess.Popen(
                command,
                shell=True,
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                text=True,
                encoding="utf-8"
            )

            with open(output_file, 'w', encoding='utf-8') as file:
                for line in iter(process.stdout.readline, ''):
                    file.write(line)
            process.wait()

            print("Scan completed. Vulnerabilities will be parsed from PwnXSS.txt.")
            self.clean_log(f"{self.results_path}\\PwnXSS.txt")
            vulnerabilities = self.extract_xss_data(output_file)
            vulnerabilities_details = {
                "Cross Site Scripting": [len(vulnerabilities), vulnerabilities]
            }

            json_report_path = os.path.join(self.report_path, "PwnXSS.json")
            with open(json_report_path, 'w', encoding='utf-8') as json_file:
                json_file.write(json.dumps(vulnerabilities_details, indent=4))  

            notifier.send_to_websocket("✅[Finished] PwnXSS Scan completed.", self.db, self.user_id, notif_type="success")

        except subprocess.CalledProcessError as e:
            print("An error occurred during the scan:", e)
            notifier.send_to_websocket(f"❌An error occurred during the scan: {e}", self.db, self.user_id, notif_type="error")

    def get_PwnXSS_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            report_path = f"{self.report_path}\\PwnXSS.json"
            with open(report_path, 'r', encoding='utf-8') as file:
                PwnXSS_vulnerabilities_details = json.load(file)    
            return PwnXSS_vulnerabilities_details
        except Exception as e:
            print(f"Error reading PwnXSS result: {e}")
            notifier.send_to_websocket(f"❌ Error reading PwnXSS result: {e}", self.db, self.user_id, notif_type="error")
            raise HTTPException(status_code=500, detail="Error generating report{e}")
        
    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        PwnXSS_results = self.get_PwnXSS_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if PwnXSS_results is None:
            print("No PwnXSS results found.")