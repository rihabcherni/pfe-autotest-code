import os
import re
import subprocess
import json
from fastapi import HTTPException
from sqlalchemy.orm import Session
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
notifier= Notifier()

class sqlmap_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'sqlmap.json')
        self.sqlmap_vulnerabilities = self.vulnerabilities
        self.resultat_path = results_path
        self.report_path = report_path
        self.output_file_path = self.resultat_path / "sqlmap_output.txt"
        self.db= db
        self.user_id = user_id

    def extract_vulnerabilities(self):
        data = []
        with open(self.output_file_path, 'r') as file:
            content = file.read()
            url_pattern = re.compile(r"(GET|POST)\s(http[^\s]+)(.*?)(?=(GET|POST)\s(http[^\s]+)|$)", re.DOTALL)
            matches = url_pattern.findall(content)
            for match in matches:
                method = match[0] 
                url = match[1]     
                following_text = match[2].strip() 

                vuln_parameter = re.compile(r"Parameter:\s([^\s]+)\s\(GET\)\s+") 
                vuln_pattern = re.compile(r"Type:\s([^\n]+)\s+Title:\s([^\n]+)\s+Payload:\s([^\n]+)")  
                vulnerabilities = vuln_pattern.findall(following_text)
                parameter = None 
                url_vulnerabilities = []
                for vuln in vulnerabilities:
                    vuln_type, title, payload = vuln

                    parameter_match = vuln_parameter.search(following_text)
                    if parameter_match:
                        parameter = parameter_match.group(1)
                    else:
                        parameter = None  

                    url_vulnerabilities.append({
                        "type": vuln_type,
                        "title": title,
                        "payload": payload
                    })
                if len(url_vulnerabilities)>0:
                    target_data = {
                        "url": url,
                        "method": method,
                        "parameter": parameter,
                        "attack": url_vulnerabilities
                    }
                    data.append(target_data)
        return data
        
    def start(self, username, password, token_auth, cookies):
        print("Starting the scan sqlmap...")
        notifier.send_to_websocket("Starting the scan sqlmap...", self.db, self.user_id, notif_type="info")
        
        try:
            with open(self.output_file_path, 'w') as outfile:
                # command = (
                #     f"docker run --rm parrotsec/sqlmap "
                #     f"--mount type=bind,source={self.resultat_path},target=/mnt/results "
                #     f"-u {self.url} --batch --level={self.setting['sqlmap_level']} "
                #     f"--risk={self.setting['sqlmap_risk']} --random-agent "
                #     f"--crawl={self.setting['depth_crawl']} "
                #     f"--answers='already=N,follow=Y,crawl=Y,sitemap=Y,skip=N' "
                #     f"--threads={self.setting['sqlmap_threads']} --technique={self.setting['sqlmap_technique']} --flush-session "
                #     f"--output-dir=/mnt/results/"
                # )
                # if username and password:
                #     command+=f' --auth-type Basic --auth-cred "{username}:{password}"'  
                # elif cookies:
                #     command+=f" --cookie {cookies}"
                command = [
                    "bash", "commands.sh",
                    self.url, self.hostname, "sqlmap",
                    username or "", password or "", cookies or "",self.resultat_path
                ]
                process = subprocess.Popen(
                    command,
                    shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.STDOUT,
                    text=True
                )
                for line in iter(process.stdout.readline, ''):
                    output = line.strip()
                    clean_content = re.sub(r'\x1b\[[0-9;]*[A-Za-z]', '', output)
                    outfile.write(clean_content + '\n')
                process.wait()
                notifier.send_to_websocket("[Finished] sqlmap Scan completed.", self.db, self.user_id, notif_type="success")
                
        except subprocess.CalledProcessError as e:
            print("An error occurred during the scan:", e)
            notifier.send_to_websocket(f"An error occurred during the scan Sqlmap: {e}", self.db, self.user_id, notif_type="error")
            
        except Exception as e:
            print("An unexpected error occurred:", e)
            notifier.send_to_websocket(f"An unexpected error occurred Sqlmap: {e}", self.db, self.user_id, notif_type="error")
            

    def get_sqlmap_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            vulnerabilities = self.extract_vulnerabilities()
            json_report = json.dumps(vulnerabilities, indent=4)   
            sqlmap_vulnerabilities_details = {} 
            if len(vulnerabilities)> 0:       
                sqlmap_vulnerabilities_details = {
                    "SQL Injection": [len(vulnerabilities), vulnerabilities]
                }   
            saved_results_path = self.save_report_to_json(sqlmap_vulnerabilities_details, "sqlmap", self.report_path)        
            report_file_path = os.path.join(self.resultat_path, f"sqlmap.json")
            with open(report_file_path, 'w') as report_file:
                report_file.write(json_report)
            return sqlmap_vulnerabilities_details

        except Exception as e:
            print(f"Error reading sqlmap result: {e}")
            notifier.send_to_websocket(f"Error reading sqlmap result: {e}", self.db, self.user_id, notif_type="error")
            
            raise HTTPException(status_code=500, detail="Error generating report")

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        sqlmap_results = self.get_sqlmap_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if sqlmap_results is None:
            print("No sqlmap results found.")