import os
import subprocess
import json
from sqlalchemy.orm import Session
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.scan import Scan
notifier=Notifier()

class wafw00f_scan(Scan):
    def __init__(self, setting, url, report_path, results_path, db, user_id):
        super().__init__(setting, url, 'wafw00f.json')
        self.wafw00f_vulnerabilities = self.vulnerabilities
        self.resultat_path = os.path.join(results_path, 'wafw00f.json') 
        self.report_path = report_path
        self.db = db
        self.user_id = user_id

    def clean_log(self, input_file: str):
        if not os.path.exists(input_file):
            raise ValueError(f"Le fichier wafw00f {input_file} est introuvable.")
            
        if os.path.getsize(input_file) == 0:
            raise ValueError(f"Le fichier wafw00f {input_file} est vide.")

        try:
            with open(input_file, "r", encoding='utf-8') as f:
                raw_data = json.load(f)
        except json.JSONDecodeError as e:
            raise ValueError(f"Le fichier wafw00f {input_file} contient du JSON invalide: {e}")
            
        report = []
        for entry in raw_data:
            result = {
                "url": entry.get("url"), 
                "waf": entry.get("waf")
            }

            cleaned_result = {k: v for k, v in result.items() if v is not None and v != []}
            report.append(cleaned_result)
        return report
    def start(self, username=None, password=None, token_auth=None, cookies=None):
        print("Starting the scan wafw00f...")
        notifier.send_to_websocket("Starting the scan wafw00f...", self.db, self.user_id, notif_type="info")

        try:
            os.makedirs(os.path.dirname(self.resultat_path), exist_ok=True)
            scan_result = []

            # Obtenir le chemin relatif à la racine projet
            relative_result_path = os.path.relpath(self.resultat_path, os.getcwd())
            docker_output_path = f'/data/{relative_result_path.replace(os.sep, "/")}'

            command = [
                'docker', 'run', '--rm',
                '-v', f'{os.getcwd()}:/data',
                'osodevops/wafw00f:latest',
                self.url,
                '--output', docker_output_path
            ]

            print("Running command:", " ".join(command))

            process = subprocess.run(
                command,
                capture_output=True,
                text=True,
                check=False
            )

            print("Command stdout:\n", process.stdout)
            print("Command stderr:\n", process.stderr)

            if process.returncode != 0:
                error_msg = f"wafw00f scan failed with code {process.returncode}: {process.stderr}"
                print(error_msg)
                notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
                with open(self.resultat_path, 'w') as f:
                    json.dump([], f)
                return

            # Lecture du fichier de sortie écrit par le container Docker
            if os.path.exists(self.resultat_path):
                with open(self.resultat_path, 'r', encoding='utf-8') as f:
                    try:
                        scan_result = json.load(f)
                    except json.JSONDecodeError:
                        print("Le fichier résultat n'est pas au format JSON valide.")
                        scan_result = []

            print(f"wafw00f scan completed successfully. Results saved to {self.resultat_path}")
            notifier.send_to_websocket("[Finished] wafw00f Scan completed.", self.db, self.user_id, notif_type="success")

        except Exception as e:
            error_msg = f"An unexpected error occurred in wafw00f scan: {e}"
            print(error_msg)
            notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
            with open(self.resultat_path, 'w') as f:
                json.dump([], f)


    # def start(self, username, password, token_auth, cookies):
    #     print("Starting the scan wafw00f...")
    #     notifier.send_to_websocket("Starting the scan wafw00f...", self.db, self.user_id, notif_type="info")
        
    #     try:
    #         os.makedirs(os.path.dirname(self.resultat_path), exist_ok=True)
    #         scan_result = []

    #         command = [
    #             'docker', 'run','--rm',
    #             '-v', f'{os.getcwd()}:/data',
    #             'osodevops/wafw00f:latest',
    #             self.url,
    #             '--output', f'/data/{self.resultat_path}'
    #         ]
    #         process = subprocess.run(
    #             command,
    #             capture_output=True,
    #             text=True,
    #             check=False
    #         )
    #         print("=== wafw00f stdout ===")
    #         print(process.stdout)

    #         print("=== wafw00f stderr ===")
    #         print(process.stderr)

    #         if process.returncode != 0:
    #             error_msg = f"wafw00f scan failed with code {process.returncode}: {process.stderr}"
    #             print(error_msg)
    #             notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
                
    #             with open(self.resultat_path, 'w') as f:
    #                 json.dump([], f)
    #             return
        
    #         # output_lines = process.stdout.strip().split('\n')
    #         # for line in output_lines:
    #         #     line = line.strip()
    #         #     if not line:
    #         #         continue
    #         #     try:
    #         #         scan_result.append(json.loads(line))
    #         #     except json.JSONDecodeError:
    #         #         pass

    #         # with open(self.resultat_path, 'w', encoding='utf-8') as outfile:
    #         #     json.dump(scan_result, outfile)
    #         print(f"wafw00f scan completed successfully. Results saved to {self.resultat_path}")
    #         notifier.send_to_websocket("[Finished] wafw00f Scan completed.", self.db, self.user_id, notif_type="success")
            

    #     except Exception as e:
    #         error_msg = f"An unexpected error occurred in wafw00f scan: {e}"
    #         print(error_msg)
    #         notifier.send_to_websocket(error_msg, self.db, self.user_id, notif_type="error")
            
    #         with open(self.resultat_path, 'w') as f:
    #             json.dump([], f)

    def get_wafw00f_results(self, token, channel_id, emails, db: Session, user_id: int, save_to_db=True):
        try:
            # Check if file exists and has content before processing
            if not os.path.exists(self.resultat_path):
                print(f"Warning: Results file not found at {self.resultat_path}")
                notifier.send_to_websocket(f"Results file not found", self.db, self.user_id, notif_type="warning")
                
                return []
                
            if os.path.getsize(self.resultat_path) == 0:
                print(f"Warning: Results file is empty at {self.resultat_path}")
                notifier.send_to_websocket(f"Results file is empty", self.db, self.user_id, notif_type="warning")
                
                return []
            
            results = self.clean_log(self.resultat_path)
            saved_results_path = self.save_report_to_json(results, "wafw00f", self.report_path)
            return results

        except Exception as e:
            print(f"Error reading wafw00f result: {e}")
            notifier.send_to_websocket(f"Error reading wafw00f result: {e}", self.db, self.user_id, notif_type="error")
            
            return []  

    def read_report(self, token, channel_id, emails, db: Session, user_id: int):
        wafw00f_results = self.get_wafw00f_results(token, channel_id, emails, db, user_id, save_to_db=False)
        if not wafw00f_results:
            print("No wafw00f results found.")
            notifier.send_to_websocket("No wafw00f results found", self.db, self.user_id, notif_type="warning")
            