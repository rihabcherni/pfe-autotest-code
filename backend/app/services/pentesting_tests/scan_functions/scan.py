import os
from datetime import datetime
import json
from sqlalchemy.orm import Session
from app.models.report import Report
from app.models.security import SecurityReportDetails, Vulnerability, VulnerabilityCategory
from app.services.pentesting_tests.scan_functions.scan_check import ScanChecker
from pathlib import Path
from urllib.parse import urlparse
from dotenv import load_dotenv 

load_dotenv()

class Scan:
    def __init__(self, setting, url, json_filename):
        self.setting = setting
        self.url = url
        self.hostname =  urlparse(url).netloc
        self.json_path = self.get_vulnerabilities_json_path(json_filename)
        self.ajax_option = False

        with open(self.json_path, 'r') as file:
            self.vulnerabilities = json.load(file)
            self.vulnerabilities = self.vulnerabilities.copy()

    def get_folder_path(self, folder):
        current_path = None
        for root, dirs, files in os.walk(os.path.abspath('.')):
            if folder in dirs:
                current_path = os.path.join(root, folder)
                break
        if not current_path:
            print(f"Le dossier {folder} n'a pas été trouvé dans le projet.")
        return  Path(current_path)
    
    def get_vulnerabilities_json_path(self, filename):
        vulnerabilities_type_path= self.get_folder_path('vulnerabilities_model')
        return os.path.join(vulnerabilities_type_path, filename) if vulnerabilities_type_path else None

    def get_file_path(self, folder_name, *args):
        folder_path = os.path.abspath(folder_name) 
        folder_path = os.path.normpath(folder_path)  
        file_path = os.path.join(folder_path, *args)
        os.makedirs(os.path.dirname(file_path), exist_ok=True)
        if not os.path.exists(file_path):
            with open(file_path, 'w') as convert_file:
                json.dump({}, convert_file)
        return file_path

      # Save scan results to a JSON file
    def save_report_to_json(self, results, report_name, folder_report):
        if not os.path.exists(folder_report):
            os.makedirs(folder_report)
        report_file_path = self.get_file_path(folder_report, f'{report_name}.json')
        try:
            with open(report_file_path, 'w', encoding='utf-8') as f:
                json.dump(results, f, ensure_ascii=False, indent=4)
            print(f"Report saved to {report_file_path}")
            return report_file_path
        except Exception as e:
            print(f"Error saving the report: {e}")
            return None

    def save_report(self, user_id: int, report_path: str, db: Session):
        try:
            report_file_path = report_path / "final_report.json"
            with open(report_file_path, 'rb') as file:
                data = json.loads(file.read().decode('utf-8'))
            details = data["details"]
            host_metadata = data.get("host_metadata", {})
            all_vulns = data.get("vulnerability_categories", {})
            report = db.query(Report).filter(Report.id == self.report_db_id).first()
            if not report:
                print("❌ Rapport introuvable. Impossible de modifier un rapport inexistant.")
                return
            report.scan_finished_at = datetime.now()
            report.status = "completed"
            db.commit()
            print("✅ Rapport existant mis à jour.")
            db.query(SecurityReportDetails).filter(SecurityReportDetails.report_id == report.id).delete()
            db.commit()
            security_details = SecurityReportDetails(
                report_id=report.id,
                number_vulnerabilities=details.get("number_vulnerabilities", 0),
                total_High=details.get("total_High", 0),
                total_Medium=details.get("total_Medium", 0),
                total_Low=details.get("total_Low", 0),
                total_Informational=details.get("total_Informational", 0),
                tools_used=",".join(details.get("tools_used", [])),
                host_metadata = host_metadata

            )
            db.add(security_details)
            db.flush()
            # Insertion des catégories et vulnérabilités
            for category_name, category_data in all_vulns.items():
                category = VulnerabilityCategory(
                    security_report_id=security_details.id,
                    title=category_name,
                    total=category_data.get("total", 0),
                    risk=category_data.get("risk", ""),
                    details=json.dumps(category_data.get("details", [])),
                    tools=",".join(category_data.get("all_tools", []))
                )
                db.add(category)
                db.flush()
                for vuln in category_data.get("vulnerabilities", []):
                    v = Vulnerability(
                        category_id=category.id,
                        url=vuln.get("url"),
                        method=vuln.get("method"),
                        parameters=vuln.get("parameter"),
                        attack=json.dumps(vuln.get("attack")),
                        real_name=", ".join(vuln.get("real_name", [])),
                        detected_by=", ".join(vuln.get("detected_by", [])),
                        confidence=vuln.get("confidence", ""),
                        confidence_score=str(vuln.get("confidence_score", ""))
                    )
                    db.add(v)
            db.commit()
            print("✅ Détails et vulnérabilités mis à jour avec succès.")
        except Exception as e:
            db.rollback()
            print(f"❌ Erreur lors de la mise à jour du rapport : {e}")
    @staticmethod
    def setup_scan(setting, url):
        Scan_check = ScanChecker()
        Scan_check.configure_new_scan( setting, url)
        Scan_check.check()
