from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
import threading
from requests import Session
from app.models.report import Report
from app.services.notifier import Notifier
from app.services.pentesting_tests.scan_functions.crawler import Crawler
from app.services.pentesting_tests.scan_functions.getCookies import dynamic_authentication, get_cookies_after_login
from app.services.pentesting_tests.scan_functions.scan import Scan

from app.services.pentesting_tests.scan_functions.scan_tools.wapiti_scan import wapiti_scan
from app.services.pentesting_tests.scan_functions.scan_tools.zap_scan import ZAP_scan
from app.services.pentesting_tests.scan_functions.scan_tools.sqlmap_scan import sqlmap_scan
from app.services.pentesting_tests.scan_functions.scan_tools.XSStrike_scan import XSStrike_scan
from app.services.pentesting_tests.scan_functions.scan_tools.nikto_scan import nikto_scan
from app.services.pentesting_tests.scan_functions.scan_tools.nmap_scan import nmap_scan
from app.services.pentesting_tests.scan_functions.scan_tools.PwnXSS_scan import PwnXSS_scan
from app.services.pentesting_tests.scan_functions.scan_tools.nuclei_scan import nuclei_scan
from app.services.pentesting_tests.scan_functions.scan_tools.whatweb_scan import Whatweb_scan
from app.services.pentesting_tests.scan_functions.scan_tools.wafw00f_scan import wafw00f_scan

from app.services.pentesting_tests.scan_functions.compare_report import CompareReport
import time
from urllib.parse import urlparse
import time
import os
import sys
sys.stdout.reconfigure(encoding='utf-8')
notifier = Notifier() 

class ThreadScan(Scan):
    def __init__(self, script_dir, setting, url, scan_tools):
        self.script_dir = script_dir
        self.setting = setting
        self.url = url
        self.hostname = urlparse(url).netloc
        timestamp = int(time.time())
        self.unique_id = f"{self.hostname.replace(':', '_')}-{timestamp}"
        self.report_path =  self.get_folder_path("Reports") / self.unique_id
        self.results_path =  self.get_folder_path("Results") / self.unique_id
        self.liste_scan_tools=scan_tools
        self.stop_event = threading.Event() 

        if not os.path.exists(self.report_path):
            os.makedirs(self.report_path)
        if not os.path.exists(self.results_path):
            os.makedirs(self.results_path)
        Scan.setup_scan(self.setting, self.url)
        self.startTime=  datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        self.total_scans = 0
        self.completed_scans = 0

    def run_scan(self, scan_type, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, 
        jira_project_key, db, user_id, username=None, password=None, token_auth=None, cookies=None):

        if self.stop_event.is_set():
            print(f"üö´ Scan {scan_type} interrompu avant d√©marrage.")
            return
        if self.stop_event.is_set():
            print(f"üö´ Scan {scan_type} interrompu en cours d'ex√©cution.")
            return
        
        if username and password and cookies=="":
            cookies = get_cookies_after_login(self.url, username, password)
            # cookies = dynamic_authentication(self.url, username, password)
            print( "cookies:"+cookies)
        scanners = {
            "zap": ZAP_scan,
            "wapiti": wapiti_scan,
            "sqlmap": sqlmap_scan,
            "xsstrike": XSStrike_scan,
            "nikto": nikto_scan,
            "nmap": nmap_scan,
            "pwnxss": PwnXSS_scan,
            "nuclei": nuclei_scan,
            "wafw00f": wafw00f_scan,
            "whatweb": Whatweb_scan,
        }
        scanner_class = scanners.get(scan_type)
        if not scanner_class:
            print(f"‚ùå Scan type '{scan_type}' non reconnu.")
            return
        scanner = scanner_class(self.setting, self.url, self.report_path, self.results_path,db, user_id)
        print(f"üöÄ Lancement du scan {scan_type} sur {self.url}...")
        try:
            if(scan_type=="zap"):
                scanner.start()
                timestamp = time.strftime("%Y%m%d-%H%M%S") 
                context_name = f"new_{self.url}_{timestamp}"  
                scanner.check_for_zap(username=username, password=password, token_auth=token_auth, cookies=cookies, context_name=context_name)
            else:
                scanner.start(username=username, password=password, token_auth=token_auth, cookies=cookies)
            scanner.read_report(token, channel_id, emails, db, user_id)
            # scanner.check_results_for_risk(token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, jira_project_key, db, user_id)
            print(f"‚úÖ Scan {scan_type} termin√© avec succ√®s !")
        except Exception as e:
            print(f"‚ùå Erreur lors du scan {scan_type}: {e}")
    
    def run_scan_with_progress(self, scan_type, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, jira_project_key, db, user_id, username=None, password=None, token_auth=None, cookies=None):
        if self.stop_event.is_set():
            print(f"üö´ Scan {scan_type} ignor√© √† cause de l'annulation.")
            return
        self.run_scan(scan_type, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, jira_project_key, db, user_id, username, password, token_auth, cookies)
        self.completed_scans += 1
        percent_done = int((self.completed_scans / self.total_scans) * 100)
        progress_message = f"üìä Progression: {percent_done}% ({self.completed_scans}/{self.total_scans})"
        print(progress_message)
        notifier.send_to_websocket(progress_message, db=db, user_id=user_id, notif_type="progression")

    def create_report_entry(self, db: Session, user_id: int, authentification: bool):
        new_report = Report(
            user_id=user_id,
            scan_type="security",
            authentification=authentification,
            schedule_scan=False,
            scan_started_at=self.startTime,
            url= self.url,
            status="running"
        )
        db.add(new_report)
        db.commit()
        db.refresh(new_report)
        self.report_db_id = new_report.id

    def run_all_scans(self, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, jira_project_key, db, user_id, username=None, password=None, token_auth=None, cookies=None):
        self.notify_scan_start(token, channel_id, db, user_id)
        authentification = bool(username or password or token_auth or cookies)
        # crawler = Crawler(self.url, self.setting, self.hostname, self.unique_id)
        # crawler.start_spider_scan()  
        scan_types = self.liste_scan_tools
        self.total_scans = len(scan_types)
        self.completed_scans = 0
        with ThreadPoolExecutor(max_workers=3) as executor:  
            future_to_scan = {
                executor.submit(self.run_scan_with_progress, scan_type, token, channel_id, emails, jira_email, jira_token, jira_domain, jira_board, jira_project_key, db, user_id, username, password, token_auth, cookies): scan_type
                for scan_type in scan_types
            }
            for future in as_completed(future_to_scan):
                if self.stop_event.is_set():
                    print("üö´ Arr√™t des scans demand√©, interruption...")
                    break
                scan_type = future_to_scan[future]
                try:
                    future.result()  
                except Exception as exc:
                    print(f"‚ùå Scan {scan_type} a √©chou√© avec une exception : {exc}")

        if username or password or token_auth or cookies:
            authentification= True
        else:
            authentification= False
        comparator = CompareReport(self.report_path, self.unique_id, self.url, self.startTime, authentification)
        comparator.load_reports()
        comparator.save_final_report()
        self.save_report(user_id, self.report_path, db)
        self.notify_scan_completion(token, channel_id, db, user_id)

    def notify_scan_start(self, token, channel_id, db, user_id):
        date_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        message = f"Scan started at {date_time}"
        notifier.send_message_to_slack(token, channel_id, message, file=None)
        notifier.send_to_websocket("Scan started", db=db, user_id=user_id, notif_type="info")

    def notify_scan_completion(self, token, channel_id, db, user_id):
        date_time = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        message = f"Scan completed at {date_time}"
        notifier.send_message_to_slack(token, channel_id, message, file=None)
        notifier.send_to_websocket(message, db=db, user_id=user_id, notif_type="success")
        notifier.send_results(token, channel_id, self.report_path, db, user_id)
