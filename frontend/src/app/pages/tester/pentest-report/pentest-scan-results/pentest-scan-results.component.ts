import { Component, OnInit, OnDestroy } from '@angular/core';
import { ActivatedRoute } from '@angular/router';
import { HttpClient } from '@angular/common/http';
import { interval, Subscription } from 'rxjs';
import { switchMap, takeWhile } from 'rxjs/operators';
import { TitleComponent } from '../../../../components/shared/title/title.component';
import { FormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { FilteredVulnerability, LogEntry, ToolResult, Vulnerability, VulnerabilityCategory } from '../../../../models/pentest-scan';
import { Reports } from '../../../../models/report';
import { NotificationService } from '../../../../services/notification/notification.service';
import { AuthService } from '../../../../services/auth/auth.service';
import { DownloadComponent } from "../../../../components/shared/download/download.component";

@Component({
  selector: 'app-pentest-scan-results',
  standalone: true,
  imports: [CommonModule, FormsModule, TitleComponent, DownloadComponent],
  templateUrl: './pentest-scan-results.component.html',
  styleUrls: ['./pentest-scan-results.component.css']
})
export class PentestScanResultsComponent implements OnInit, OnDestroy {
  reportData: Reports | null = null;
  loading = true;
  error: string | null = null;
  scanProgress = 0;
  receivedMessages: string[] = []; 
  scanCancelled = false;
  cancelling = false;
  selectedTab = 'summary';
  titleValue = "Security Scanner (Results)";
  targetUrl = '';
  targetIp = '';
  serverInfo = '';
  scanStartTime: Date | null = null;
  scanEndTime: Date | null = null;
  scanCompleteTime: Date | null = null;
  scanCancelledTime: Date | null = null;
  scanDuration = '';
  toolsUsed: string[] = [];
  vulnerabilityCounts = {
    other: 0,
    high: 0,
    medium: 0,
    low: 0,
    informational: 0
  };  
  total_vuln=0;
  riskScore = 0;
  riskCategory = '';
  riskScoreClass = '';
  riskAssessment = '';
  searchVulnerability = '';
  severityFilter = '';
  toolFilter = '';
  filteredVulnerabilities: FilteredVulnerability[] = [];
  allVulnerabilities: FilteredVulnerability[] = [];
  toolResults: ToolResult[] = [];
  scanLogs: LogEntry[] = [];
  partialResults: any[] = [];
  private pollingSubscription?: Subscription;
  private websocketSubscription?: Subscription;
  private reportId: number = 0;
  userId!: number;
  constructor(
    private notificationService: NotificationService, 
    private authService: AuthService,
    private route: ActivatedRoute, 
    private http: HttpClient
  ) {}
  ngOnInit() {
    this.userId = this.authService.getUserId()!;
    if (!this.userId) {
      console.warn('No user ID found in token');
      return;
    }
    this.route.params.subscribe(params => {
      this.reportId = +params['id'];
      this.loadReport();
      this.initializeWebSocket();
      this.startPolling();
    });
  }  
  ngOnDestroy() {
    if (this.pollingSubscription) {
      this.pollingSubscription.unsubscribe();
    }
    if (this.websocketSubscription) {
      this.websocketSubscription.unsubscribe();
    }
    this.notificationService.disconnect();
  } 
  expandedDescriptions: Record<number, boolean> = {};
  expandedSolutions: Record<number, boolean> = {};

  toggleDescription(index: number): void {
    this.expandedDescriptions[index] = !this.expandedDescriptions[index];
  }

  toggleSolution(index: number): void {
    this.expandedSolutions[index] = !this.expandedSolutions[index];
  }

  truncate(text: string, limit: number = 200): string {
    return text.length > limit ? text.slice(0, limit) + '...' : text;
  }
 
  private initializeWebSocket() {
    this.notificationService.connectToWebSocket(this.userId);    
    this.websocketSubscription = this.notificationService.notifications$.subscribe({
      next: (notification: any) => {
        console.log('WebSocket notification received:', notification);        
        if (notification.message && notification.message.includes(`scan_${this.reportId}`)) {
          this.handleWebSocketMessage(notification.message);
        } else if (notification.message) {
          this.handleWebSocketMessage(notification.message);
        }
      },
      error: (error) => {
        console.error('WebSocket error:', error);
        this.addLogEntry('error', 'WebSocket', 'Connection error occurred');
      }
    });
  }
  private handleWebSocketMessage(message: any) {
    try {
      let messageData: string;
      
      if (typeof message === 'string') {
        messageData = message;
      } else if (message.data) {
        messageData = typeof message.data === 'string' ? message.data : JSON.stringify(message.data);
      } else {
        messageData = JSON.stringify(message);
      }
      this.receivedMessages.push(messageData);      
      const progressPatterns = [
        /(?:Progression|Progress)\s*:?\s*(\d+)%/i,
        /(\d+)%\s*(?:complete|completed|progress)/i,
        /progress\s*:\s*(\d+)/i,
        /scan\s*:\s*(\d+)%/i
      ];
      for (const pattern of progressPatterns) {
        const progressMatch = messageData.match(pattern);
        if (progressMatch && progressMatch[1]) {
          const newProgress = parseInt(progressMatch[1], 10);
          if (newProgress !== this.scanProgress && !isNaN(newProgress) && newProgress >= 0 && newProgress <= 100) {
            this.scanProgress = newProgress;
            this.addLogEntry('info', 'System', `Scan progress: ${this.scanProgress}%`);
            break;
          }
        }
      }
      const toolMatch = messageData.match(/^(\w+):\s*(.+)/);
      if (toolMatch) {
        const toolName = toolMatch[1];
        const toolMessage = toolMatch[2];
        this.addLogEntry('info', toolName, toolMessage);
      } else {
        this.addLogEntry('info', 'System', messageData);
      }
      if (messageData.toLowerCase().includes('completed') || 
          messageData.toLowerCase().includes('finished') ||
          messageData.toLowerCase().includes('scan complete')) {
        this.scanProgress = 100;
        this.scanCompleteTime = new Date();
        this.addLogEntry('success', 'System', 'Scan completed successfully');
        this.loadReport();
      }
      if (messageData.toLowerCase().includes('error') || 
          messageData.toLowerCase().includes('failed')) {
        this.addLogEntry('error', 'System', messageData);
      }
      if (messageData.toLowerCase().includes('cancelled') || 
          messageData.toLowerCase().includes('stopped')) {
        this.scanCancelled = true;
        this.scanCancelledTime = new Date();
        this.addLogEntry('warning', 'System', 'Scan was cancelled');
      }
      const toolStartPatterns = [
        /starting\s+(\w+)/i,
        /running\s+(\w+)/i,
        /executing\s+(\w+)/i,
        /(\w+)\s+started/i
      ];
      for (const pattern of toolStartPatterns) {
        const toolStartMatch = messageData.match(pattern);
        if (toolStartMatch && toolStartMatch[1]) {
          const toolName = toolStartMatch[1];
          this.addLogEntry('info', toolName, `${toolName} scan initiated`);
          if (!this.toolsUsed.includes(toolName)) {
            this.toolsUsed.push(toolName);
          }
          break;
        }
      }
    } catch (error) {
      console.error('Error processing WebSocket message:', error);
      this.addLogEntry('error', 'System', 'Error processing scan update');
    }
  }
  private addLogEntry(level: string, tool: string, message: string) {
    const logEntry: LogEntry = {
      timestamp: new Date(),
      level: level,
      tool: tool,
      message: message
    };
    this.scanLogs.push(logEntry);        
    if (this.scanLogs.length > 100) {
      this.scanLogs = this.scanLogs.slice(-100);
    }
  }
  private loadReport() {
    this.loading = true;
    this.error = null; 
    this.http.get<Reports>(`http://localhost:8000/reports/${this.reportId}`)
      .subscribe({
        next: (data) => {
          console.log(data)
          this.reportData = data;
          this.processReportData();
          this.loading = false;
        },
        error: (error) => {
          this.error = 'Failed to load report data';
          this.loading = false;
          console.error('Error loading report:', error);
        }
      });
  }
  private startPolling() {
    this.pollingSubscription = interval(5000)
      .pipe(
        switchMap(() => this.http.get<Reports>(`http://localhost:8000/reports/${this.reportId}`)),
        takeWhile((data) => {
          const shouldContinue = data.status !== 'completed' && 
                                data.status !== 'failed' && 
                                data.status !== 'cancelled';
          return shouldContinue;
        }, true)
      )
      .subscribe({
        next: (data) => {
          this.reportData = data;
          this.processReportData();
        },
        error: (error) => {
          console.error('Polling error:', error);
          this.addLogEntry('error', 'System', 'Failed to fetch report updates');
        }
      });
  }
  private processReportData() {
    if (!this.reportData) return;
    this.targetUrl = this.reportData.url;
    this.scanStartTime = new Date(this.reportData.scan_started_at);    
    this.scanEndTime = new Date(this.reportData.scan_finished_at);    
    switch (this.reportData.status) {
      case 'completed':
        if (this.scanProgress < 100) {
          this.scanProgress = 100;
        }
        this.scanCompleteTime = this.reportData.scan_finished_at ? new Date(this.reportData.scan_finished_at) : null;
        break;
      case 'cancelled':
        this.scanCancelled = true;
        this.scanCancelledTime = this.reportData.scan_finished_at ? new Date(this.reportData.scan_finished_at) : null;
        break;
      case 'running':
        break;
      case 'failed':
        this.addLogEntry('error', 'System', 'Scan failed');
        break;
      default:
        if (this.scanProgress === 0) {
          this.addLogEntry('info', 'System', 'Scan initialization...');
        }
    }    
    if (this.scanStartTime) {
      const endTime = this.scanCompleteTime || this.scanCancelledTime || new Date();
      const durationMs = endTime.getTime() - this.scanStartTime.getTime();
      const minutes = Math.floor(durationMs / 60000);
      const seconds = Math.floor((durationMs % 60000) / 1000);
      this.scanDuration = `${minutes}m ${seconds}s`;
    }    
    if (this.reportData.security_details) {
      this.processSecurityDetails();
    }
  }
  private processSecurityDetails() {
    const securityDetails = this.reportData!.security_details!;    
    if (securityDetails.host_metadata && securityDetails.host_metadata.length > 0) {
      const metadata = securityDetails.host_metadata[0];
      this.targetIp = metadata['IP Address'] || '';
      this.serverInfo = metadata.Server || '';
    }
    this.toolsUsed = securityDetails.tools_used ? securityDetails.tools_used.split(',') : [];    
    this.vulnerabilityCounts = {
      other: securityDetails.total_High, 
      high: securityDetails.total_High || 0,
      medium: securityDetails.total_Medium || 0,
      low: securityDetails.total_Low || 0,
      informational: securityDetails.total_Informational || 0
    };    
    this.total_vuln= this.vulnerabilityCounts.other+ this.vulnerabilityCounts.high+ this.vulnerabilityCounts.low+ this.vulnerabilityCounts.medium+ this.vulnerabilityCounts.informational;
    this.calculateRiskAssessment();    
    this.processVulnerabilities();
    this.generateToolResults();    

    if (this.scanLogs.length === 0) {
      this.generateInitialScanLogs();
    }
  }
  private calculateRiskAssessment() {
    const counts = this.vulnerabilityCounts;
    this.riskScore = (counts.other * 1) + (counts.high * 10) + (counts.medium * 5) + (counts.low * 1);
    if (this.riskScore >= 50) {
      this.riskCategory = 'Critical Risk';
      this.riskScoreClass = 'critical';
      this.riskAssessment = 'Immediate action required. Multiple high-severity vulnerabilities detected.';
    } else if (this.riskScore >= 25) {
      this.riskCategory = 'High Risk';
      this.riskScoreClass = 'high';
      this.riskAssessment = 'Significant security issues found. Remediation recommended.';
    } else if (this.riskScore >= 10) {
      this.riskCategory = 'Medium Risk';
      this.riskScoreClass = 'medium';
      this.riskAssessment = 'Some security concerns identified. Review and address as needed.';
    } else {
      this.riskCategory = 'Low Risk';
      this.riskScoreClass = 'low';
      this.riskAssessment = 'Minimal security issues detected. Continue monitoring.';
    }
  }
  private processVulnerabilities() {
    if (!this.reportData?.security_details?.categories) return;
    this.allVulnerabilities = [];
    (this.reportData.security_details.categories as VulnerabilityCategory[]).forEach((category: VulnerabilityCategory) => {
      if (category.vulnerabilities) {
        category.vulnerabilities.forEach((vuln: Vulnerability) => {
          let details: any = {};
          try {
            if (category.details) {
              const detailsArray = JSON.parse(category.details);
              details = detailsArray[0] || {};
            }
          } catch (e) {
            console.error('Error parsing category details:', e);
          }

          this.allVulnerabilities.push({
            id: vuln.id,
            name: vuln.real_name,
            tool: vuln.detected_by,

            severity: category.risk.toLowerCase(),
            category: category.title,
            total_category: category.total,
            details_category: category.details,
            tools_category: category.tools,
            description: details.description || 'No description available',
            affectedUrl: vuln.url,
            evidence: vuln.attack || '',
            remediation: details.solution || 'No remediation available',
            references: details.reference ? details.reference : [],
            showDetails: false,
            score: ''
          });
        });
      }
    }); 

    this.filteredVulnerabilities = [...this.allVulnerabilities];
  }

  private generateToolResults() {
    this.toolResults = this.toolsUsed.map(tool => ({
      name: tool,
      findings: this.allVulnerabilities
        .filter(v => v.tool === tool)
        .map(v => ({
          message: v.name,
          severity: v.severity,
          location: v.affectedUrl
        }))
    }));
  }

  private generateInitialScanLogs() {
    this.scanLogs = [
      {
        timestamp: this.scanStartTime || new Date(),
        level: 'info',
        tool: 'System',
        message: `Scan started for ${this.targetUrl}`
      }
    ];

    this.toolsUsed.forEach((tool, index) => {
      const timestamp = new Date((this.scanStartTime?.getTime() || 0) + (index + 1) * 60000);
      this.scanLogs.push({
        timestamp,
        level: 'info',
        tool: tool,
        message: `${tool} scan initiated`
      });
    });    

    if (this.scanProgress === 100) {
      this.scanLogs.push({
        timestamp: this.scanCompleteTime || new Date(),
        level: 'success',
        tool: 'System',
        message: 'Scan completed successfully'
      });
    }
  }

  filterVulnerabilities() {
    this.filteredVulnerabilities = this.allVulnerabilities.filter(vuln => {
      const matchesSearch = !this.searchVulnerability || 
        vuln.name.toLowerCase().includes(this.searchVulnerability.toLowerCase()) ||
        vuln.description.toLowerCase().includes(this.searchVulnerability.toLowerCase());
      const matchesSeverity = !this.severityFilter || vuln.severity === this.severityFilter;
      const matchesTool = !this.toolFilter || vuln.tool === this.toolFilter;      
      
      return matchesSearch && matchesSeverity && matchesTool;
    });
  }
  cancelScan() {
    this.cancelling = true;        
    this.notificationService.sendMessage(`cancel_scan_${this.reportId}`);        
    this.http.post(`http://localhost:8000/scan/cancel/${this.reportId}`, {})
      .subscribe({
        next: () => {
          this.scanCancelled = true;
          this.cancelling = false;
          this.scanCancelledTime = new Date();
          this.addLogEntry('warning', 'System', 'Scan cancellation requested');
        },
        error: (error) => {
          console.error('Error cancelling scan:', error);
          this.cancelling = false;
          this.addLogEntry('error', 'System', 'Failed to cancel scan');
        }
      });
  }

  exportReport(format: string) {
    console.log(`Export ${format} clicked`);
    this.http.get(`http://localhost:8000/reports/download/${this.reportId}/${format}`, { responseType: 'blob' })
      .subscribe({
        next: (blob) => {
          const url = window.URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `security-report-${this.reportId}.${format}`;
          a.click();
          window.URL.revokeObjectURL(url);
        },
        error: (error) => {
          console.error(`Error exporting ${format}:`, error);
        }
      });
  }

    exportToCSV = async () => {
       this.exportReport('csv');
    }
     exportToPDF = async () => {
       this.exportReport('pdf');
    }
     exportToHTML = async () => {
       this.exportReport('html');
    }
    downloadAllAsZip = async () => {
       this.exportReport('zip');
    }

  newScan() {
    console.log('New scan clicked');
  }  
  downloadLogs() {
    const logContent = this.scanLogs.map(log => 
      `[${log.timestamp.toISOString()}] ${log.level.toUpperCase()} - ${log.tool}: ${log.message}`
    ).join('\n'); 
    const blob = new Blob([logContent], { type: 'text/plain' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `scan-logs-${this.reportId}.txt`;
    a.click();
    window.URL.revokeObjectURL(url);
  }
getFilteredCategories(): VulnerabilityCategory[] {
  if (!this.reportData?.security_details?.categories) return [];
    const riskPriority: { [key: string]: number } = {
    'high': 4,
    'medium': 3,
    'low': 2,
    'informational': 1
  };
  
  return (this.reportData.security_details.categories as VulnerabilityCategory[])
    .filter(category => {
      if (this.severityFilter && category.risk.toLowerCase() !== this.severityFilter) {
        return false;
      }
      if (this.toolFilter && category.tools !== this.toolFilter) {
        return false;
      }      
      if (this.searchVulnerability) {
        const searchTerm = this.searchVulnerability.toLowerCase();
        const matchesTitle = category.title.toLowerCase().includes(searchTerm);
        const matchesDescription = this.getCategoryDetails(category).description?.toLowerCase().includes(searchTerm);
        const matchesVulnerabilities = category.vulnerabilities?.some(vuln => 
          vuln.real_name.toLowerCase().includes(searchTerm) ||
          vuln.url.toLowerCase().includes(searchTerm)
        );
        
        if (!matchesTitle && !matchesDescription && !matchesVulnerabilities) {
          return false;
        }
      }
      
      return true;
    })
    .sort((a, b) => {
      const priorityA = riskPriority[a.risk.toLowerCase()] || 0;
      const priorityB = riskPriority[b.risk.toLowerCase()] || 0;      
      return priorityB - priorityA;
    });
}


  getFilteredVulnerabilitiesForCategory(category: VulnerabilityCategory): Vulnerability[] {
    if (!category.vulnerabilities) return [];    
    return category.vulnerabilities.filter(vuln => {
      if (this.searchVulnerability) {
        const searchTerm = this.searchVulnerability.toLowerCase();
        const matchesName = vuln.real_name.toLowerCase().includes(searchTerm);
        const matchesUrl = vuln.url.toLowerCase().includes(searchTerm);
        const matchesAttack = vuln.attack?.toLowerCase().includes(searchTerm);
        
        if (!matchesName && !matchesUrl && !matchesAttack) {
          return false;
        }
      }
      if (this.toolFilter && vuln.detected_by !== this.toolFilter) {
        return false;
      }
      
      return true;
    });
  }
  getCategoryDetails(category: VulnerabilityCategory): any {
    try {
      if (category.details) {
        const detailsArray = JSON.parse(category.details);
        return detailsArray[0] || {};
      }
    } catch (e) {
      console.error('Error parsing category details:', e);
    }
    return {};
  }
  formatAttackData(attack: string): string {
    try {
      const attackArray = JSON.parse(attack);
      if (Array.isArray(attackArray)) {
        return attackArray.map((item, index) => `${index + 1}. ${item}`).join('\n');
      }
      return attack;
    } catch (e) {
      return attack;
    }
  }
  getVulnerabilityCountForCategory(category: VulnerabilityCategory): number {
    return category.vulnerabilities ? category.vulnerabilities.length : 0;
  }
  getRiskBadgeClass(risk: string): string {
    switch (risk.toLowerCase()) {
      case 'high':
        return 'bg-danger';
      case 'medium':
        return 'bg-warning text-dark';
      case 'low':
        return 'bg-success';
      case 'informational':
        return 'bg-info';
      default:
        return 'bg-secondary';
    }
  }
  getConfidenceBadgeClass(confidence: string): string {
    switch (confidence.toLowerCase()) {
      case 'high':
        return 'bg-success';
      case 'medium':
        return 'bg-warning text-dark';
      case 'low':
        return 'bg-secondary';
      default:
        return 'bg-light text-dark';
    }
  }
    getConfidenceScorePercentage(score: string): number {
      try {
        return parseFloat(score) || 0;
      } catch (e) {
        return 0;
      }
    }
}