import { Component, ViewChild, AfterViewInit, OnInit } from '@angular/core';
import { MatTableDataSource } from '@angular/material/table';
import { MatPaginator, MatPaginatorModule } from '@angular/material/paginator';
import { MatSort } from '@angular/material/sort';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { CommonModule } from '@angular/common';
import { ReportsService } from '../../../../services/reports/reports.service';
import { Reports } from '../../../../models/report';
import jsPDF from 'jspdf';
import autoTable from 'jspdf-autotable';
import { saveAs } from 'file-saver';
import JSZip from 'jszip';
import { SecurityTableDetailsComponent } from "../../../../components/shared/all-report-details/security-table-details/security-table-details.component";
import { TitleComponent } from "../../../../components/shared/title/title.component";
import { AuthService } from '../../../../services/auth/auth.service';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatSnackBar } from '@angular/material/snack-bar';
import { MatMenuModule } from '@angular/material/menu';
import { DownloadComponent } from "../../../../components/shared/download/download.component";
import { Router } from '@angular/router';
import { SearchInputComponent } from "../../../../components/shared/search-input/search-input.component";
import { Vulnerability } from '../../../../models/pentest-scan';

@Component({
  selector: 'app-pentest-reports',
  standalone: true,
  imports: [
    MatExpansionModule, MatProgressSpinnerModule, CommonModule, MatMenuModule, MatFormFieldModule, MatInputModule, MatIconModule,
    MatButtonModule, SecurityTableDetailsComponent, TitleComponent, MatPaginatorModule, DownloadComponent,SearchInputComponent
],
  templateUrl: './pentest-reports.component.html',
  styleUrl: './pentest-reports.component.css'
})
export class PentestReportsComponent implements AfterViewInit, OnInit {
  userId!: number;
  displayedColumns: string[] = ['scan_type', 'url', 'status', 'scan_started_at', 'scan_finished_at'];
  dataSource = new MatTableDataSource<Reports>([]);
  @ViewChild(MatPaginator) paginator!: MatPaginator;
  defaultPageSize = 5;
  @ViewChild(MatSort) sort!: MatSort;
  titleValue = "Security Scan (Reports)";
  isDownloading = false;
  currentReport: Reports | null = null;
  searchTerm: string = '';
  paginatedData: Reports[] = [];

  constructor(
    private reportsService: ReportsService, 
    private authService: AuthService,   
    private snackBar: MatSnackBar,
    private router: Router
  ) {}
  navigateToNewReport(): void {
    this.router.navigate(['/tester/pentest-scan']);
  }
  ngOnInit() {
    this.loadReports();
  }
  loadReports(): void {
    this.userId = this.authService.getUserId()!;
    if (!this.userId) return;

    this.reportsService.getSecurityReports(this.userId).subscribe({
      next: (reports) => {
        this.dataSource.data = reports;
        this.updatePaginatedData(); 
      },
      error: (err) => {
        console.error('Erreur lors du chargement des rapports Security', err);
      }
    });
  }
  updatePaginatedData() {
    if (!this.paginator || !this.dataSource?.filteredData) return;

    const pageSize = this.paginator.pageSize || this.defaultPageSize;
    const pageIndex = this.paginator.pageIndex || 0;
    const startIndex = pageIndex * pageSize;
    const endIndex = startIndex + pageSize;

    this.paginatedData = this.dataSource.filteredData.slice(startIndex, endIndex);
  }
  ngAfterViewInit() {
    this.dataSource.paginator = this.paginator;
    this.dataSource.sort = this.sort;
    setTimeout(() => this.updatePaginatedData(), 0);
    this.paginator.page.subscribe(() => {
      this.updatePaginatedData();
    });
  }
  applyFilter() {
    this.dataSource.filter = this.searchTerm.trim().toLowerCase();
    if (this.paginator) {
      this.paginator.firstPage();
    }
    this.updatePaginatedData();
  }

  hasHighRisk(report: Reports): boolean {
    return !!report.security_details && report.security_details.total_High > 0;
  }

  hasMediumRisk(report: Reports): boolean {
    return !this.hasHighRisk(report) && !!report.security_details && report.security_details.total_Medium > 0;
  }

  hasLowRisk(report: Reports): boolean {
    return !this.hasHighRisk(report) && !this.hasMediumRisk(report);
  }

  getStatusIcon(report: Reports): string {
    switch(report.status.toLowerCase()) {
      case 'completed':
        return 'check_circle';
      case 'in progress':
        return 'hourglass_top';
      case 'failed':
        return 'error';
      default:
        return 'info';
    }
  }

  getStatusIconClass(report: Reports): string {
    switch(report.status.toLowerCase()) {
      case 'completed':
        return 'text-green-500';
      case 'in progress':
        return 'text-blue-500';
      case 'failed':
        return 'text-red-500';
      default:
        return 'text-gray-500';
    }
  }
  private showMessage(message: string, type: 'success' | 'error' | 'info'): void {
    const config = {
      duration: type === 'error' ? 5000 : 3000,
      panelClass: [`snackbar-${type}`],
      horizontalPosition: 'end' as const,
      verticalPosition: 'top' as const,
    };

    this.snackBar.open(message, 'Close', config);
  }
  isFormatAvailable(format: string): boolean {
    const availableFormats = ['pdf', 'html', 'csv', 'zip'];
    return availableFormats.includes(format.toLowerCase());
  }
  getEstimatedSize(format: string): string {
    const sizes: { [key: string]: string } = {
      'pdf': '~2-5 MB',
      'html': '~500 KB',
      'csv': '~100 KB',
      'zip': '~3-8 MB'
    };
    return sizes[format] || 'Unknown';
  }
  viewTestResults(report: Reports): void {
    if (report.id) {
      this.router.navigate(['/tester/pentest-scan-results', report.id]);
    } else {
      this.showMessage('Report ID not available', 'error');
    }
  }
  deleteReport(report: Reports, event?: Event): void {
    if (event) {
      event.stopPropagation();
    }
    const confirmed = confirm(`Are you sure you want to delete this report for ${report.url}?`);
    
    if (confirmed) {
      this.reportsService.deleteReport(report.id).subscribe({
        next: () => {
          const currentData = this.dataSource.data;
          const updatedData = currentData.filter(r => r.id !== report.id);
          this.dataSource.data = updatedData;
          
          this.showMessage('Report deleted successfully', 'success');
        },
        error: (err) => {
          console.error('Error deleting report:', err);
          this.showMessage('Failed to delete report', 'error');
        }
      });
    }
  }  
    exportAllToPdf = async (): Promise<void> => {
    const doc = new jsPDF();
    doc.setFontSize(18);
    doc.text('Security Scan Reports Summary', 14, 20);
    
    const tableColumn = ["Scan Type", "URL", "Status", "Vulnerabilities", "High Risk", "Medium Risk"];
    const tableRows: any[] = [];
    
    this.dataSource.data.forEach(report => {
      const reportData = [
        report.scan_type,
        report.url,
        report.status,
        report.security_details?.number_vulnerabilities || 0,
        report.security_details?.total_High || 0,
        report.security_details?.total_Medium || 0
      ];
      tableRows.push(reportData);
    });
    
    (doc as any).autoTable({
      head: [tableColumn],
      body: tableRows,
      startY: 30,
      theme: 'striped',
      headStyles: { fillColor: [66, 139, 202] }
    });
    
    doc.save('all_security_reports.pdf');
  }
  exportToPDF = async (): Promise<void> => {
    if (!this.currentReport) {
      this.showMessage('No report selected for export', 'error');
      return;
    }
    
    this.isDownloading = true;
    
    try {
      this.showMessage('Generating PDF report...', 'info');
      await this.generateSingleReportPDF(this.currentReport);
      this.showMessage('PDF report generated successfully!', 'success');
    } catch (error) {
      console.error('PDF generation error:', error);
      this.showMessage('Failed to generate PDF report', 'error');
    } finally {
      this.isDownloading = false;
    }
  }
  exportToHTML = async (): Promise<void> => {
    if (!this.currentReport) {
      this.showMessage('No report selected for export', 'error');
      return;
    }
    this.isDownloading = true;
    try {
      this.showMessage('Generating HTML report...', 'info');
      await this.generateSingleReportHTML(this.currentReport);
      this.showMessage('HTML report generated successfully!', 'success');
    } catch (error) {
      console.error('HTML generation error:', error);
      this.showMessage('Failed to generate HTML report', 'error');
    } finally {
      this.isDownloading = false;
    }
  }
  exportToCSV = async (): Promise<void> => {
    if (!this.currentReport) {
      this.showMessage('No report selected for export', 'error');
      return;
    }
    
    this.isDownloading = true;
    
    try {
      this.showMessage('Generating CSV report...', 'info');
      await this.generateSingleReportCSV(this.currentReport);
      this.showMessage('CSV report generated successfully!', 'success');
    } catch (error) {
      console.error('CSV generation error:', error);
      this.showMessage('Failed to generate CSV report', 'error');
    } finally {
      this.isDownloading = false;
    }
  }
  downloadAllAsZip = async (): Promise<void> => {
    if (!this.currentReport) {
      this.showMessage('No report selected for export', 'error');
      return;
    }
    this.isDownloading = true;
    try {
      this.showMessage('Generating complete package...', 'info');
      await Promise.all([
        this.generateSingleReportPDF(this.currentReport, false),
        this.generateSingleReportHTML(this.currentReport, false),
        this.generateSingleReportCSV(this.currentReport, false)
      ]);  
      this.showMessage('Complete package generated successfully!', 'success');
    } catch (error) {
      console.error('Package generation error:', error);
      this.showMessage('Failed to generate complete package', 'error');
    } finally {
      this.isDownloading = false;
    }
  }
  setCurrentReport(report: Reports): void {
    this.currentReport = report;
  }
  private async generateSingleReportPDF(report: Reports, download: boolean = true): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        const startDate = report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A';
        const endDate = report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A';
        const doc = new jsPDF();
        doc.setFontSize(20);
        doc.text(`Security Report`, 14, 20);
        doc.setFontSize(14);
        doc.text(`Scan Type: ${report.scan_type}`, 14, 35);
        doc.text(`URL: ${report.url}`, 14, 45);
        doc.text(`Status: ${report.status}`, 14, 55);
        doc.text(`Start Date: ${startDate}`, 14, 65);
        doc.text(`End Date: ${endDate}`, 14, 75);
        if (report.security_details) {
          doc.setFontSize(16);
          doc.text('Security Analysis', 14, 95);
          
          doc.setFontSize(12);
          doc.text(`Total Vulnerabilities: ${report.security_details.number_vulnerabilities || 0}`, 14, 110);
          doc.text(`High Risk Issues: ${report.security_details.total_High || 0}`, 14, 120);
          doc.text(`Medium Risk Issues: ${report.security_details.total_Medium || 0}`, 14, 130);
          doc.text(`Low Risk Issues: ${report.security_details.total_Low || 0}`, 14, 140);
          doc.text(`Tools Used: ${report.security_details.tools_used || 'N/A'}`, 14, 150);
          if (report.security_details.vulnerabilities && report.security_details.vulnerabilities.length > 0) {
            const tableData = report.security_details.vulnerabilities.map((vuln: { name: any; severity: any; description: any; }) => [
              vuln.name || 'N/A',
              vuln.severity || 'N/A',
              vuln.description || 'N/A'
            ]);
            
            (doc as any).autoTable({
              head: [['Vulnerability', 'Severity', 'Description']],
              body: tableData,
              startY: 165,
              theme: 'striped',
              headStyles: { fillColor: [66, 139, 202] },
              columnStyles: {
                0: { cellWidth: 50 },
                1: { cellWidth: 30 },
                2: { cellWidth: 100 }
              }
            });
          }
        }
        
        if (download) {
          const fileName = `security-report-${report.id || 'unknown'}-${new Date().toISOString().slice(0, 10)}.pdf`;
          doc.save(fileName);
        }
        
        resolve();
      }, 500); 
    });
  }
  private async generateSingleReportHTML(report: Reports, download: boolean = true): Promise<void> {
    try {
      const response = await fetch('assets/templates/report-template.html');
      let template = await response.text();

      const startDate = report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A';
      const endDate = report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A';

      const security = report.security_details;
      let vulnerabilitiesTable = '';
      if (security?.vulnerabilities?.length) {
        vulnerabilitiesTable = security.vulnerabilities.map((vuln: Vulnerability) => `
          <tr>
            <td>${vuln.attack || 'N/A'}</td>
            <td>${vuln.method || 'N/A'}</td>
          </tr>
        `).join('');
      }
      template = template
        .replace('{{title}}', `Security Report - ${report.url}`)
        .replace('{{scanType}}', report.scan_type)
        .replace('{{url}}', report.url)
        .replace('{{status}}', report.status)
        .replace('{{scanDuration}}', `${startDate} - ${endDate}`)
        .replace('{{numberVuln}}', String(security?.number_vulnerabilities ?? 0))
        .replace('{{highRisk}}', String(security?.total_High ?? 0))
        .replace('{{mediumRisk}}', String(security?.total_Medium ?? 0))
        .replace('{{lowRisk}}', String(security?.total_Low ?? 0))
        .replace('{{toolsUsed}}', security?.tools_used ?? 'N/A')
        .replace('{{vulnerabilityRows}}', vulnerabilitiesTable);

      if (download) {
        const blob = new Blob([template], { type: 'text/html;charset=utf-8' });
        const fileName = `security-report-${report.id || 'unknown'}-${new Date().toISOString().slice(0, 10)}.html`;
        this.downloadBlob(blob, fileName);
      }
    } catch (err) {
      console.error('Error generating report:', err);
    }
  }
  private async generateSingleReportCSV(report: Reports, download: boolean = true): Promise<void> {
    return new Promise((resolve) => {
      setTimeout(() => {
        const csvRows = [];        
        csvRows.push(['Report ID','Scan Type','Target URL','Status','Start Date','End Date','Total Vulnerabilities','High Risk','Medium Risk','Low Risk','Tools Used']);
        const row = [
          report.id || 'N/A',
          report.scan_type || 'N/A',
          report.url || 'N/A',
          report.status || 'N/A',
          new Date(report.scan_started_at).toLocaleString(),
          new Date(report.scan_finished_at).toLocaleString()|| 'N/A',
          report.security_details?.number_vulnerabilities || 0,
          report.security_details?.total_High || 0,
          report.security_details?.total_Medium || 0,
          report.security_details?.total_Low || 0,
          report.security_details?.tools_used || 'N/A'
        ];
        csvRows.push(row);        
        if (report.security_details?.vulnerabilities && report.security_details.vulnerabilities.length > 0) {
          csvRows.push([]); 
          csvRows.push(['Detailed Vulnerabilities']);
          csvRows.push(['Name', 'Severity', 'Description']);
          
          report.security_details.vulnerabilities.forEach((vuln: { name: any; severity: any; description: any; }) => {
            csvRows.push([
              vuln.name || 'N/A',
              vuln.severity || 'N/A',
              vuln.description || 'N/A'
            ]);
          });
        }
        const csvContent = csvRows.map(row => 
          row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
        ).join('\n');
        
        if (download) {
          const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
          const fileName = `security-report-${report.id || 'unknown'}-${new Date().toISOString().slice(0, 10)}.csv`;
          this.downloadBlob(blob, fileName);
        }
        
        resolve();
      }, 200);
    });
  }
  private downloadBlob(blob: Blob, fileName: string): void {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = fileName;
    link.style.display = 'none';
    
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }
  exportAllToCSV = async () => {
    const headers = ['ID', 'Scan Type', 'URL', 'Status', 'Schedule', 'Started At', 'Finished At'];

    const rows = this.dataSource.filteredData.map(report => [
      report.id || 'N/A',
      report.scan_type || 'N/A',
      report.url || 'N/A',
      report.status || 'N/A',
      this.getScheduleText(report.schedule_scan) || 'N/A',
      report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A',
      report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A'
    ]);

    const csvContent = 'data:text/csv;charset=utf-8,' +
      [headers.join(','), ...rows.map(row => row.map(cell => `"${String(cell).replace(/"/g, '""')}"`).join(','))].join('\n');

    const blob = new Blob([decodeURIComponent(encodeURI(csvContent))], { type: 'text/csv;charset=utf-8;' });
    saveAs(blob, 'reports.csv');
  }
    exportAllReportsToPDF = async () => {
      const doc = new jsPDF('l');
      const headers = [['ID', 'Scan Type', 'URL', 'Status', 'Schedule', 'Started At', 'Finished At']];
      const rows = this.dataSource.filteredData.map(report => [
        report.id.toString(),
        report.scan_type,
        report.url,
        report.status,
        this.getScheduleText(report.schedule_scan) || 'N/A',
        report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A',
        report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A'
      ]);
  
      autoTable(doc, {
        head: headers,
        body: rows,
        startY: 20,
        styles: { fontSize: 8 },
        columnStyles: {
          2: { cellWidth: 40 },
          6: { cellWidth: 30 },
          7: { cellWidth: 30 }
        }
      });
  
      doc.save('reports.pdf');
    }
    getScheduleText(isScheduled: boolean): string {
      return isScheduled ? 'Scheduled' : 'Immediate';
    }
    exportAllToHTML = async () => {
      const headers = ['ID', 'Scan Type', 'URL', 'Status', 'Schedule', 'Started At', 'Finished At'];

      const rows = this.dataSource.filteredData.map(report => {
        const startedAt = report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A';
        const finishedAt = report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A';

        return `
          <tr>
            <td>${report.id || 'N/A'}</td>
            <td>${report.scan_type || 'N/A'}</td>
            <td>${report.url || 'N/A'}</td>
            <td>${report.status || 'N/A'}</td>
            <td>${this.getScheduleText(report.schedule_scan) || 'N/A'}</td>
            <td>${startedAt}</td>
            <td>${finishedAt}</td>
          </tr>`;
      });

      const htmlContent = `
        <!DOCTYPE html>
        <html lang="en">
          <head>
            <meta charset="UTF-8">
            <title>Reports List</title>
            <style>
              body { font-family: Arial, sans-serif; margin: 20px; background: #fff; }
              h1 { color: #333; }
              table { border-collapse: collapse; width: 100%; }
              th, td { border: 1px solid #ddd; padding: 8px; }
              th { background-color: #f2f2f2; font-weight: bold; }
              tr:nth-child(even) { background-color: #f9f9f9; }
            </style>
          </head>
          <body>
            <h1>Reports List</h1>
            <table>
              <thead>
                <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
              </thead>
              <tbody>
                ${rows.join('')}
              </tbody>
            </table>
          </body>
        </html>
      `;

      const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
      saveAs(blob, 'reports.html');
    }
  async downloadAllReportAsZip() {
    const zip = new JSZip();
    const headers = ['ID', 'Scan Type', 'URL', 'Status', 'Schedule', 'Started At', 'Finished At'];
    const csvRows = this.dataSource.filteredData.map(report => [
      report.id ?? 'N/A',
      report.scan_type ?? 'N/A',
      report.url ?? 'N/A',
      report.status ?? 'N/A',
      this.getScheduleText(report.schedule_scan) ?? 'N/A',
      report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A',
      report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A'
    ]);
    const csvContent = [
      headers.join(','),
      ...csvRows.map(row => row.map(cell => `"${cell}"`).join(','))
    ].join('\n');
    zip.file('reports.csv', csvContent);
    const htmlTableRows = this.dataSource.filteredData.map(report => {
      const startedAt = report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A';
      const finishedAt = report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A';

      return `
        <tr>
          <td>${report.id ?? 'N/A'}</td>
          <td>${report.scan_type ?? 'N/A'}</td>
          <td>${report.url ?? 'N/A'}</td>
          <td>${report.status ?? 'N/A'}</td>
          <td>${this.getScheduleText(report.schedule_scan) ?? 'N/A'}</td>
          <td>${startedAt}</td>
          <td>${finishedAt}</td>
        </tr>`;
    });

    const htmlContent = `
      <!DOCTYPE html>
      <html lang="en">
        <head>
          <meta charset="utf-8">
          <title>Reports List</title>
          <style>
            table { border-collapse: collapse; width: 100%; font-family: Arial, sans-serif; }
            th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
            th { background-color: #f2f2f2; font-weight: bold; }
            tr:nth-child(even) { background-color: #f9f9f9; }
          </style>
        </head>
        <body>
          <h1>Reports List</h1>
          <table>
            <thead>
              <tr>${headers.map(h => `<th>${h}</th>`).join('')}</tr>
            </thead>
            <tbody>
              ${htmlTableRows.join('')}
            </tbody>
          </table>
        </body>
      </html>`;
    zip.file('reports.html', htmlContent);
    const pdfDoc = new jsPDF('l');
    autoTable(pdfDoc, {
      head: [headers],
      body: this.dataSource.filteredData.map(report => [
        report.id?.toString() ?? 'N/A',
        report.scan_type ?? 'N/A',
        report.url ?? 'N/A',
        report.status ?? 'N/A',
        this.getScheduleText(report.schedule_scan) ?? 'N/A',
        report.scan_started_at ? new Date(report.scan_started_at).toLocaleString() : 'N/A',
        report.scan_finished_at ? new Date(report.scan_finished_at).toLocaleString() : 'N/A'
      ]),
      styles: { fontSize: 8 },
      columnStyles: {
        2: { cellWidth: 40 },
        5: { cellWidth: 30 },
        6: { cellWidth: 30 }
      }
    });
    const pdfBlob = pdfDoc.output('blob');
    zip.file('reports.pdf', pdfBlob);
    zip.generateAsync({ type: 'blob' }).then(zipBlob => {
      saveAs(zipBlob, 'all_reports.zip');
    });
  }
}